/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianKinopoiskPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// Views/search_modal.ts
var import_obsidian3 = require("obsidian");

// APIProvider/provider.ts
var import_obsidian2 = require("obsidian");

// i18n.ts
var ru = {
  common: {
    ok: "\u041E\u041A",
    cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
    save: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C",
    loading: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430...",
    error: "\u041E\u0448\u0438\u0431\u043A\u0430",
    success: "\u0423\u0441\u043F\u0435\u0448\u043D\u043E"
  },
  modals: {
    searchTitle: "\u{1F37F} \u041F\u043E\u0438\u0441\u043A \u0444\u0438\u043B\u044C\u043C\u0430 \u0438\u043B\u0438 \u0441\u0435\u0440\u0438\u0430\u043B\u0430",
    searchPlaceholder: "\u041F\u043E\u0438\u0441\u043A \u043F\u043E \u043A\u043B\u044E\u0447\u0435\u0432\u043E\u043C\u0443 \u0441\u043B\u043E\u0432\u0443",
    searchButton: "\u041D\u0430\u0439\u0442\u0438",
    searching: "\u041F\u043E\u0438\u0441\u043A...",
    enterMovieName: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0444\u0438\u043B\u044C\u043C\u0430 \u0438\u043B\u0438 \u0441\u0435\u0440\u0438\u0430\u043B\u0430 \u0434\u043B\u044F \u043F\u043E\u0438\u0441\u043A\u0430",
    needApiToken: "\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C API \u0442\u043E\u043A\u0435\u043D \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
    loadingMovieInfo: "\u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u0442\u0441\u044F \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u0444\u0438\u043B\u044C\u043C\u0435...",
    preparingImages: "\u041F\u043E\u0434\u0433\u043E\u0442\u043E\u0432\u043A\u0430 \u043A \u0441\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u044E \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439...",
    movieInfoLoaded: "\u0418\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u0444\u0438\u043B\u044C\u043C\u0435 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D\u0430!",
    errorMovieData: "\u041E\u0448\u0438\u0431\u043A\u0430: \u043D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435 \u0444\u0438\u043B\u044C\u043C\u0430",
    errorUnexpected: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430",
    errorGettingDetails: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0438 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0438 \u043E \u0444\u0438\u043B\u044C\u043C\u0435",
    posterPlaceholderEmoji: "\u{1F4FD}\uFE0F",
    posterTooltipGeoblock: "\u041F\u043E\u0441\u0442\u0435\u0440 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0433\u0435\u043E\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u043A\u0430)",
    posterTooltipMissing: "\u041F\u043E\u0441\u0442\u0435\u0440 \u043E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442",
    posterTooltipEmptyLink: "\u041F\u0443\u0441\u0442\u0430\u044F \u0441\u0441\u044B\u043B\u043A\u0430 \u043D\u0430 \u043F\u043E\u0441\u0442\u0435\u0440",
    posterTooltipInvalidLink: "\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u0430\u044F \u0441\u0441\u044B\u043B\u043A\u0430 \u043D\u0430 \u043F\u043E\u0441\u0442\u0435\u0440"
  },
  suggesters: {
    fileListError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0438 \u0441\u043F\u0438\u0441\u043A\u0430 \u0444\u0430\u0439\u043B\u043E\u0432:",
    folderListError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0438 \u0441\u043F\u0438\u0441\u043A\u0430 \u043F\u0430\u043F\u043E\u043A:"
  },
  validation: {
    invalidApiToken: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 API \u0442\u043E\u043A\u0435\u043D",
    invalidSearchQuery: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u043F\u043E\u0438\u0441\u043A\u043E\u0432\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441",
    invalidMovieId: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 ID \u0444\u0438\u043B\u044C\u043C\u0430",
    invalidPaginationParams: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0435 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u044B \u043F\u0430\u0433\u0438\u043D\u0430\u0446\u0438\u0438"
  },
  provider: {
    tokenRequired: "\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 API \u0442\u043E\u043A\u0435\u043D \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
    enterMovieTitle: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0444\u0438\u043B\u044C\u043C\u0430 \u0438\u043B\u0438 \u0441\u0435\u0440\u0438\u0430\u043B\u0430 \u0434\u043B\u044F \u043F\u043E\u0438\u0441\u043A\u0430",
    nothingFound: '\u041F\u043E \u0437\u0430\u043F\u0440\u043E\u0441\u0443 "{query}" \u043D\u0438\u0447\u0435\u0433\u043E \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E.',
    invalidMovieId: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ID \u0444\u0438\u043B\u044C\u043C\u0430",
    tokenRequiredForMovie: "\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 API \u0442\u043E\u043A\u0435\u043D",
    movieInfoError: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044E \u043E \u0444\u0438\u043B\u044C\u043C\u0435",
    tryChangeQuery: "\u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0438\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u043F\u043E\u0438\u0441\u043A\u043E\u0432\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441."
  },
  errorHandler: {
    badRequest: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u0432\u0432\u0435\u0434\u0435\u043D\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435.",
    unauthorized: "\u041D\u0435\u0430\u0432\u0442\u043E\u0440\u0438\u0437\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0434\u043E\u0441\u0442\u0443\u043F. \u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044C, \u0447\u0442\u043E API \u0442\u043E\u043A\u0435\u043D \u0443\u043A\u0430\u0437\u0430\u043D \u0438 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D.",
    forbidden: "\u041F\u0440\u0435\u0432\u044B\u0448\u0435\u043D \u0441\u0443\u0442\u043E\u0447\u043D\u044B\u0439 \u043B\u0438\u043C\u0438\u0442. \u041F\u043E\u0434\u043E\u0436\u0434\u0438\u0442\u0435 \u0438 \u043F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0441\u043D\u043E\u0432\u0430.",
    notFound: "\u0414\u0430\u043D\u043D\u044B\u0435 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0438\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u043F\u043E\u0438\u0441\u043A\u043E\u0432\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441.",
    tooManyRequests: "\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u043D\u043E\u0433\u043E \u0437\u0430\u043F\u0440\u043E\u0441\u043E\u0432. \u041F\u043E\u0434\u043E\u0436\u0434\u0438\u0442\u0435 \u043D\u0435\u043C\u043D\u043E\u0433\u043E \u0438 \u043F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0441\u043D\u043E\u0432\u0430.",
    internalServerError: "\u0412\u043D\u0443\u0442\u0440\u0435\u043D\u043D\u044F\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u041A\u0438\u043D\u043E\u043F\u043E\u0438\u0441\u043A\u0430. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435.",
    badGateway: "\u0421\u0435\u0440\u0432\u0435\u0440 \u041A\u0438\u043D\u043E\u043F\u043E\u0438\u0441\u043A\u0430 \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (502 Bad Gateway).",
    serviceUnavailable: "\u0421\u0435\u0440\u0432\u0438\u0441 \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D. \u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u043F\u043E\u043F\u044B\u0442\u043A\u0443 \u043F\u043E\u0437\u0436\u0435.",
    gatewayTimeout: "\u0421\u0435\u0440\u0432\u0435\u0440 \u043D\u0435 \u043E\u0442\u0432\u0435\u0447\u0430\u0435\u0442. \u041F\u0440\u0435\u0432\u044B\u0448\u0435\u043D\u043E \u0432\u0440\u0435\u043C\u044F \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F (504 Gateway Timeout).",
    networkError: "\u041F\u0440\u043E\u0431\u043B\u0435\u043C\u044B \u0441 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435\u043C \u043A \u0438\u043D\u0442\u0435\u0440\u043D\u0435\u0442\u0443. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u0435.",
    unknownStatusError: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0435 \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443 (\u043A\u043E\u0434 {status}). \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435.",
    unexpectedError: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0435. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435."
  },
  images: {
    poster: "\u043F\u043E\u0441\u0442\u0435\u0440\u0430",
    cover: "\u043E\u0431\u043B\u043E\u0436\u043A\u0438",
    logo: "\u043B\u043E\u0433\u043E\u0442\u0438\u043F\u0430",
    noImagesToDownload: "\u041D\u0435\u0442 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439 \u0434\u043B\u044F \u0441\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u044F",
    downloading: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435",
    downloadingPoster: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435 \u043F\u043E\u0441\u0442\u0435\u0440\u0430...",
    downloadingCover: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435 \u043E\u0431\u043B\u043E\u0436\u043A\u0438...",
    downloadingLogo: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435 \u043B\u043E\u0433\u043E\u0442\u0438\u043F\u0430...",
    completed: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E!",
    completedAllDownloaded: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E! \u0412\u0441\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0441\u043A\u0430\u0447\u0430\u043D\u044B",
    completedAlreadyLocal: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E! \u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0443\u0436\u0435 \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u044B\u0435",
    completedWithErrors: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E! \u0423\u0441\u043F\u0435\u0448\u043D\u043E: {successful}, \u043D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C: {failed}",
    invalidUrl: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 URL: {url}. \u041E\u0436\u0438\u0434\u0430\u043B\u0441\u044F \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 HTTP/HTTPS URL.",
    imageNotFound: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E (404): {url}",
    accessForbidden: "\u0414\u043E\u0441\u0442\u0443\u043F \u0437\u0430\u043F\u0440\u0435\u0449\u0435\u043D (403): {url}",
    serverError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 ({status}): {url}",
    httpError: "HTTP {status}: {url}",
    downloadFailed: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043A\u0430\u0447\u0430\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435: {url}",
    timeout: "\u041F\u0440\u0435\u0432\u044B\u0448\u0435\u043D\u043E \u0432\u0440\u0435\u043C\u044F \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F \u043F\u043E\u0441\u043B\u0435 {timeout}\u043C\u0441",
    downloadedWithErrors: "\u0421\u043A\u0430\u0447\u0430\u043D\u043E: {successful}/{total} \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439. \u041D\u0435\u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435.",
    imagesUnavailable: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435. \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u044E\u0442\u0441\u044F \u043E\u0440\u0438\u0433\u0438\u043D\u0430\u043B\u044C\u043D\u044B\u0435 \u0441\u0441\u044B\u043B\u043A\u0438.",
    processingError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439",
    posterUnavailable: "\u041F\u043E\u0441\u0442\u0435\u0440 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0437\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435)",
    coverUnavailable: "\u041E\u0431\u043B\u043E\u0436\u043A\u0430 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430 (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0437\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D\u0430 \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435)",
    logoUnavailable: "\u041B\u043E\u0433\u043E\u0442\u0438\u043F \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0437\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435)",
    downloadError: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043A\u0430\u0447\u0430\u0442\u044C"
  },
  utils: {
    unknownMovie: "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u044B\u0439 \u0444\u0438\u043B\u044C\u043C",
    copyPrefix: "\u041A\u043E\u043F\u0438\u044F",
    templateNotFound: "\u0428\u0430\u0431\u043B\u043E\u043D \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D",
    templateReadError: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u0440\u043E\u0447\u0438\u0442\u0430\u0442\u044C \u0444\u0430\u0439\u043B \u0448\u0430\u0431\u043B\u043E\u043D\u0430"
  },
  settings: {
    apiToken: "API \u0422\u043E\u043A\u0435\u043D",
    apiTokenDesc: "\u0412\u0430\u043C \u043D\u0443\u0436\u043D\u043E \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C API \u0442\u043E\u043A\u0435\u043D \u0434\u043B\u044F \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u044D\u0442\u043E\u0433\u043E \u043F\u043B\u0430\u0433\u0438\u043D\u0430. \u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0431\u0435\u0441\u043F\u043B\u0430\u0442\u043D\u044B\u0439 \u043F\u043B\u0430\u043D \u0438 \u0441\u043B\u0435\u0434\u0443\u0439\u0442\u0435 \u0438\u043D\u0441\u0442\u0440\u0443\u043A\u0446\u0438\u044F\u043C.",
    getApiToken: "\u041F\u043E\u043B\u0443\u0447\u0438\u0442\u044C API \u0422\u043E\u043A\u0435\u043D",
    checkToken: "\u041F\u0440\u043E\u0432\u0435\u0440\u0438\u0442\u044C \u0442\u043E\u043A\u0435\u043D",
    checking: "\u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C...",
    tokenValid: "\u2705 \u0422\u043E\u043A\u0435\u043D \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D!",
    tokenInvalid: "\u274C \u0422\u043E\u043A\u0435\u043D \u043D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0442\u043E\u043A\u0435\u043D\u0430.",
    tokenError: "\u274C \u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0435 \u0442\u043E\u043A\u0435\u043D\u0430. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435.",
    enterToken: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 API \u0442\u043E\u043A\u0435\u043D \u0434\u043B\u044F \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0438",
    imagesHeading: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F",
    saveImagesLocally: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u043E",
    saveImagesLocallyDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432 \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u0443\u044E \u043F\u0430\u043F\u043A\u0443 \u0432\u043C\u0435\u0441\u0442\u043E \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u0432\u0435\u0431-\u0441\u0441\u044B\u043B\u043E\u043A.",
    imagesFolder: "\u041F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439",
    imagesFolderDesc: "\u041F\u0430\u043F\u043A\u0430, \u0433\u0434\u0435 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B \u0441\u043A\u0430\u0447\u0430\u043D\u043D\u044B\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F.",
    imagesFolderPlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: attachments/kinopoisk",
    savePosterImage: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043F\u043E\u0441\u0442\u0435\u0440\u044B",
    savePosterImageDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043F\u043E\u0441\u0442\u0435\u0440\u044B \u0444\u0438\u043B\u044C\u043C\u043E\u0432/\u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
    saveCoverImage: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043E\u0431\u043B\u043E\u0436\u043A\u0438",
    saveCoverImageDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043E\u0431\u043B\u043E\u0436\u043A\u0438/\u0431\u044D\u043A\u0434\u0440\u043E\u043F\u044B \u0444\u0438\u043B\u044C\u043C\u043E\u0432/\u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
    saveLogoImage: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043B\u043E\u0433\u043E\u0442\u0438\u043F\u044B",
    saveLogoImageDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043B\u043E\u0433\u043E\u0442\u0438\u043F\u044B \u0444\u0438\u043B\u044C\u043C\u043E\u0432/\u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
    moviesHeading: "\u0424\u0438\u043B\u044C\u043C\u044B",
    movieFileName: "\u0418\u043C\u044F \u0444\u0430\u0439\u043B\u0430 \u0444\u0438\u043B\u044C\u043C\u0430",
    movieFileNameDesc: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u0434\u043B\u044F \u0444\u0438\u043B\u044C\u043C\u043E\u0432.",
    movieFileNamePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: {{nameForFile}} ({{year}})",
    movieFileLocation: "\u0420\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u0444\u0430\u0439\u043B\u043E\u0432 \u0444\u0438\u043B\u044C\u043C\u043E\u0432",
    movieFileLocationDesc: "\u041D\u043E\u0432\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E \u0444\u0438\u043B\u044C\u043C\u0430\u0445 \u0431\u0443\u0434\u0443\u0442 \u0440\u0430\u0437\u043C\u0435\u0449\u0435\u043D\u044B \u0437\u0434\u0435\u0441\u044C.",
    movieFileLocationPlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: \u043F\u0430\u043F\u043A\u04301/\u043F\u0430\u043F\u043A\u04302",
    movieTemplateFile: "\u0424\u0430\u0439\u043B \u0448\u0430\u0431\u043B\u043E\u043D\u0430 \u0434\u043B\u044F \u0444\u0438\u043B\u044C\u043C\u043E\u0432",
    movieTemplateFileDesc: "\u0424\u0430\u0439\u043B\u044B \u0431\u0443\u0434\u0443\u0442 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u043A\u0430\u043A \u0448\u0430\u0431\u043B\u043E\u043D\u044B.",
    movieTemplateFilePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: templates/template-file",
    exampleTemplate: "\u041F\u0440\u0438\u043C\u0435\u0440 \u0448\u0430\u0431\u043B\u043E\u043D\u0430",
    seriesHeading: "\u0421\u0435\u0440\u0438\u0430\u043B\u044B",
    seriesFileName: "\u0418\u043C\u044F \u0444\u0430\u0439\u043B\u0430 \u0441\u0435\u0440\u0438\u0430\u043B\u0430",
    seriesFileNameDesc: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u0434\u043B\u044F \u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
    seriesFileNamePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: {{nameForFile}} ({{year}})",
    seriesFileLocation: "\u0420\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u0444\u0430\u0439\u043B\u043E\u0432 \u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432",
    seriesFileLocationDesc: "\u041D\u043E\u0432\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E \u0441\u0435\u0440\u0438\u0430\u043B\u0430\u0445 \u0431\u0443\u0434\u0443\u0442 \u0440\u0430\u0437\u043C\u0435\u0449\u0435\u043D\u044B \u0437\u0434\u0435\u0441\u044C.",
    seriesFileLocationPlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: \u043F\u0430\u043F\u043A\u04301/\u043F\u0430\u043F\u043A\u04302",
    seriesTemplateFile: "\u0424\u0430\u0439\u043B \u0448\u0430\u0431\u043B\u043E\u043D\u0430 \u0434\u043B\u044F \u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432",
    seriesTemplateFileDesc: "\u0424\u0430\u0439\u043B\u044B \u0431\u0443\u0434\u0443\u0442 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u043A\u0430\u043A \u0448\u0430\u0431\u043B\u043E\u043D\u044B.",
    seriesTemplateFilePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: templates/template-file",
    peopleHeading: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043F\u0435\u0440\u0441\u043E\u043D",
    actorsFileLocation: "\u041F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u0430\u043A\u0442\u0451\u0440\u043E\u0432",
    actorsFileLocationDesc: "\u041F\u0430\u043F\u043A\u0430, \u0432 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C\u0441\u044F \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E\u0431 \u0430\u043A\u0442\u0451\u0440\u0430\u0445",
    actorsFileLocationPlaceholder: "\u041F\u0440\u0438\u043C\u0435\u0440: \u041B\u044E\u0434\u0438/\u0410\u043A\u0442\u0451\u0440\u044B",
    directorsFileLocation: "\u041F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u0440\u0435\u0436\u0438\u0441\u0441\u0451\u0440\u043E\u0432",
    directorsFileLocationDesc: "\u041F\u0430\u043F\u043A\u0430, \u0432 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C\u0441\u044F \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E \u0440\u0435\u0436\u0438\u0441\u0441\u0451\u0440\u0430\u0445",
    directorsFileLocationPlaceholder: "\u041F\u0440\u0438\u043C\u0435\u0440: \u041B\u044E\u0434\u0438/\u0420\u0435\u0436\u0438\u0441\u0441\u0451\u0440\u044B",
    writersFileLocation: "\u041F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u0441\u0446\u0435\u043D\u0430\u0440\u0438\u0441\u0442\u043E\u0432",
    writersFileLocationDesc: "\u041F\u0430\u043F\u043A\u0430, \u0432 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C\u0441\u044F \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E \u0441\u0446\u0435\u043D\u0430\u0440\u0438\u0441\u0442\u0430\u0445",
    writersFileLocationPlaceholder: "\u041F\u0440\u0438\u043C\u0435\u0440: \u041B\u044E\u0434\u0438/\u0421\u0446\u0435\u043D\u0430\u0440\u0438\u0441\u0442\u044B",
    producersFileLocation: "\u041F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u043F\u0440\u043E\u0434\u044E\u0441\u0435\u0440\u043E\u0432",
    producersFileLocationDesc: "\u041F\u0430\u043F\u043A\u0430, \u0432 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C\u0441\u044F \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E \u043F\u0440\u043E\u0434\u044E\u0441\u0435\u0440\u0430\u0445",
    producersFileLocationPlaceholder: "\u041F\u0440\u0438\u043C\u0435\u0440: \u041B\u044E\u0434\u0438/\u041F\u0440\u043E\u0434\u044E\u0441\u0435\u0440\u044B",
    language: "\u042F\u0437\u044B\u043A \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430",
    languageDesc: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u044F\u0437\u044B\u043A \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430 \u043F\u043B\u0430\u0433\u0438\u043D\u0430."
  }
};
var en = {
  common: {
    ok: "OK",
    cancel: "Cancel",
    save: "Save",
    loading: "Loading...",
    error: "Error",
    success: "Success"
  },
  modals: {
    searchTitle: "\u{1F37F} Search movie or TV show",
    searchPlaceholder: "Search by keyword",
    searchButton: "Search",
    searching: "Searching...",
    enterMovieName: "Enter movie or TV show name to search",
    needApiToken: "API token must be specified in plugin settings",
    loadingMovieInfo: "Loading movie information...",
    preparingImages: "Preparing to download images...",
    movieInfoLoaded: "Movie information loaded!",
    errorMovieData: "Error: invalid movie data",
    errorUnexpected: "An unexpected error occurred",
    errorGettingDetails: "An unexpected error occurred while getting movie information",
    posterPlaceholderEmoji: "\u{1F4FD}\uFE0F",
    posterTooltipGeoblock: "Poster unavailable (possibly geo-blocked)",
    posterTooltipMissing: "Poster missing",
    posterTooltipEmptyLink: "Empty poster link",
    posterTooltipInvalidLink: "Invalid poster link"
  },
  suggesters: {
    fileListError: "Error getting file list:",
    folderListError: "Error getting folder list:"
  },
  validation: {
    invalidApiToken: "Invalid API token",
    invalidSearchQuery: "Invalid search query",
    invalidMovieId: "Invalid movie ID",
    invalidPaginationParams: "Invalid pagination parameters"
  },
  provider: {
    tokenRequired: "Valid API token must be specified in plugin settings",
    enterMovieTitle: "Enter movie or TV show title to search",
    nothingFound: 'Nothing found for query "{query}".',
    invalidMovieId: "Invalid movie ID",
    tokenRequiredForMovie: "Valid API token must be specified",
    movieInfoError: "Failed to get movie information",
    tryChangeQuery: "Try changing the search query."
  },
  errorHandler: {
    badRequest: "Bad request. Please check the entered data.",
    unauthorized: "Unauthorized access. Make sure the API token is specified and valid.",
    forbidden: "Daily limit exceeded. Please wait and try again.",
    notFound: "Data not found. Try changing the search query.",
    tooManyRequests: "Too many requests. Please wait a bit and try again.",
    internalServerError: "Kinopoisk server internal error. Try again later.",
    badGateway: "Kinopoisk server temporarily unavailable (502 Bad Gateway).",
    serviceUnavailable: "Service temporarily unavailable. Try again later.",
    gatewayTimeout: "Server not responding. Timeout exceeded (504 Gateway Timeout).",
    networkError: "Internet connection problems. Check your connection.",
    unknownStatusError: "An error occurred when requesting the server (code {status}). Try again later.",
    unexpectedError: "An unexpected error occurred during the request. Try again later."
  },
  images: {
    poster: "poster",
    cover: "cover",
    logo: "logo",
    noImagesToDownload: "No images to download",
    downloading: "Downloading",
    downloadingPoster: "Downloading poster...",
    downloadingCover: "Downloading cover...",
    downloadingLogo: "Downloading logo...",
    completed: "Completed!",
    completedAllDownloaded: "Completed! All images downloaded",
    completedAlreadyLocal: "Completed! Images are already local",
    completedWithErrors: "Completed! Successful: {successful}, failed: {failed}",
    invalidUrl: "Invalid URL format: {url}. Expected valid HTTP/HTTPS URL.",
    imageNotFound: "Image not found (404): {url}",
    accessForbidden: "Access forbidden (403): {url}",
    serverError: "Server error ({status}): {url}",
    httpError: "HTTP {status}: {url}",
    downloadFailed: "Failed to download image: {url}",
    timeout: "Timeout after {timeout}ms",
    downloadedWithErrors: "Downloaded: {successful}/{total} images. Some are unavailable in your region.",
    imagesUnavailable: "Images are unavailable in your region. Using original links.",
    processingError: "Error processing images",
    posterUnavailable: "Poster unavailable (possibly blocked in your region)",
    coverUnavailable: "Cover unavailable (possibly blocked in your region)",
    logoUnavailable: "Logo unavailable (possibly blocked in your region)",
    downloadError: "Failed to download"
  },
  utils: {
    unknownMovie: "Unknown Movie",
    copyPrefix: "Copy",
    templateNotFound: "Template not found",
    templateReadError: "Failed to read template file"
  },
  settings: {
    apiToken: "API Token",
    apiTokenDesc: "You need to get API token to use this plugin. Choose free plan and follow steps.",
    getApiToken: "Get API Token",
    checkToken: "Check Token",
    checking: "Checking...",
    tokenValid: "\u2705 Token is valid!",
    tokenInvalid: "\u274C Token is invalid. Please check your token.",
    tokenError: "\u274C Error checking token. Please try again later.",
    enterToken: "Enter API token to check",
    imagesHeading: "Images",
    saveImagesLocally: "Save images locally",
    saveImagesLocallyDesc: "Download and save images to local folder instead of using web URLs.",
    imagesFolder: "Images folder",
    imagesFolderDesc: "Folder where downloaded images will be saved.",
    imagesFolderPlaceholder: "Example: attachments/kinopoisk",
    savePosterImage: "Save poster images",
    savePosterImageDesc: "Download and save movie/series poster images.",
    saveCoverImage: "Save cover/backdrop images",
    saveCoverImageDesc: "Download and save movie/series cover/backdrop images.",
    saveLogoImage: "Save logo images",
    saveLogoImageDesc: "Download and save movie/series logo images.",
    moviesHeading: "Movies",
    movieFileName: "Movie file name",
    movieFileNameDesc: "Enter the movie file name format.",
    movieFileNamePlaceholder: "Example: {{nameForFile}} ({{year}})",
    movieFileLocation: "Movie file location",
    movieFileLocationDesc: "New movie notes will be placed here.",
    movieFileLocationPlaceholder: "Example: folder1/folder2",
    movieTemplateFile: "Movie template file",
    movieTemplateFileDesc: "Files will be available as templates.",
    movieTemplateFilePlaceholder: "Example: templates/template-file",
    exampleTemplate: "Example Template",
    seriesHeading: "TV series",
    seriesFileName: "TV series file name",
    seriesFileNameDesc: "Enter the TV series file name format.",
    seriesFileNamePlaceholder: "Example: {{nameForFile}} ({{year}})",
    seriesFileLocation: "TV series file location",
    seriesFileLocationDesc: "New TV series notes will be placed here.",
    seriesFileLocationPlaceholder: "Example: folder1/folder2",
    seriesTemplateFile: "TV series template file",
    seriesTemplateFileDesc: "Files will be available as templates.",
    seriesTemplateFilePlaceholder: "Example: templates/template-file",
    peopleHeading: "People Settings",
    actorsFileLocation: "Actors folder",
    actorsFileLocationDesc: "Folder where actor notes will be created",
    actorsFileLocationPlaceholder: "Example: People/Actors",
    directorsFileLocation: "Directors folder",
    directorsFileLocationDesc: "Folder where director notes will be created",
    directorsFileLocationPlaceholder: "Example: People/Directors",
    writersFileLocation: "Writers folder",
    writersFileLocationDesc: "Folder where writer notes will be created",
    writersFileLocationPlaceholder: "Example: People/Writers",
    producersFileLocation: "Producers folder",
    producersFileLocationDesc: "Folder where producer notes will be created",
    producersFileLocationPlaceholder: "Example: People/Producers",
    language: "Interface language",
    languageDesc: "Select the plugin interface language."
  }
};
var translations = {
  ru,
  en
};
var currentLanguage = "en";
function initializeLanguage(userPreference) {
  var _a;
  if (userPreference) {
    currentLanguage = userPreference;
    return;
  }
  const systemLang = navigator.language || ((_a = navigator.languages) == null ? void 0 : _a[0]);
  if (systemLang == null ? void 0 : systemLang.startsWith("ru")) {
    currentLanguage = "ru";
  } else {
    currentLanguage = "en";
  }
}
function setLanguage(language) {
  currentLanguage = language;
}
function getSupportedLanguages() {
  return [
    { code: "ru", name: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439" },
    { code: "en", name: "English" }
  ];
}
function t(key) {
  const keys = key.split(".");
  let value = translations[currentLanguage];
  for (const k of keys) {
    if (value && typeof value === "object" && k in value) {
      value = value[k];
    } else {
      console.warn(`Translation key not found: ${key}`);
      return key;
    }
  }
  return typeof value === "string" ? value : key;
}
function tWithParams(key, params) {
  let translation = t(key);
  for (const [paramKey, paramValue] of Object.entries(params)) {
    translation = translation.replace(
      new RegExp(`\\{${paramKey}\\}`, "g"),
      String(paramValue)
    );
  }
  return translation;
}

// APIProvider/ErrorHandler.ts
var NETWORK_ERROR_PATTERNS = [
  "net::",
  "NetworkError",
  "Failed to fetch",
  "ENOTFOUND",
  "ECONNREFUSED",
  "ETIMEDOUT"
];
var ErrorHandler = class {
  /**
   * Returns localized error message for HTTP status code
   */
  getHttpStatusMessage(status) {
    const statusMessages = {
      400: t("errorHandler.badRequest"),
      401: t("errorHandler.unauthorized"),
      403: t("errorHandler.forbidden"),
      404: t("errorHandler.notFound"),
      429: t("errorHandler.tooManyRequests"),
      500: t("errorHandler.internalServerError"),
      502: t("errorHandler.badGateway"),
      503: t("errorHandler.serviceUnavailable"),
      504: t("errorHandler.gatewayTimeout")
    };
    return statusMessages[status] || "";
  }
  /**
   * Processes API errors and creates user-friendly error messages
   */
  handleApiError(error) {
    const errorDetails = this.extractErrorDetails(error);
    if (errorDetails.isNetworkError) {
      return new Error(t("errorHandler.networkError"));
    }
    const knownMessage = this.getHttpStatusMessage(errorDetails.status);
    if (knownMessage) {
      return new Error(knownMessage);
    }
    if (errorDetails.status > 0) {
      return new Error(
        tWithParams("errorHandler.unknownStatusError", {
          status: errorDetails.status.toString()
        })
      );
    }
    return new Error(t("errorHandler.unexpectedError"));
  }
  /**
   * Extracts error details from various error formats
   */
  extractErrorDetails(error) {
    const details = {
      status: 0,
      message: "",
      isNetworkError: false,
      originalError: error
    };
    if (this.isNetworkError(error)) {
      details.isNetworkError = true;
      return details;
    }
    details.status = this.extractStatusCode(error);
    return details;
  }
  isNetworkError(error) {
    if (!(error instanceof Error)) {
      return false;
    }
    return NETWORK_ERROR_PATTERNS.some(
      (pattern) => error.message.includes(pattern)
    );
  }
  /**
   * Extracts HTTP status code from error object
   */
  extractStatusCode(error) {
    if (!error || typeof error !== "object") {
      return 0;
    }
    if ("status" in error && typeof error.status === "number") {
      return error.status;
    }
    if ("response" in error && error.response && typeof error.response === "object" && "status" in error.response && typeof error.response.status === "number") {
      return error.response.status;
    }
    if ("statusCode" in error && typeof error.statusCode === "number") {
      return error.statusCode;
    }
    return 0;
  }
  logError(context, error) {
    console.error(`[${context}] Error:`, error);
  }
};

// Utils/utils.ts
var import_obsidian = require("obsidian");
function capitalizeFirstLetter(input) {
  if (!input || input.length === 0) {
    return input || "";
  }
  return input.charAt(0).toUpperCase() + input.slice(1);
}
function replaceIllegalFileNameCharactersInString(text) {
  if (!text) {
    return "";
  }
  return text.replace(/[\\/:*?"<>|]/g, "");
}
function getPlainValueFromArray(value) {
  if (Array.isArray(value)) {
    if (value.length === 0) return "";
    if (value.length === 1) {
      const firstValue = value[0];
      if (typeof firstValue === "string") {
        return firstValue.replace(/^"(.*)"$/, "$1");
      }
      return firstValue != null ? firstValue : "";
    }
    return value.filter((item) => item != null).map((item) => {
      if (typeof item === "string") {
        return item.replace(/^"(.*)"$/, "$1");
      }
      return String(item);
    }).join(", ");
  }
  if (typeof value === "number") {
    return value;
  }
  return String(value || "");
}
function getQuotedValueFromArray(value) {
  if (Array.isArray(value)) {
    if (value.length === 0) return "";
    if (value.length === 1) {
      const firstValue = String(value[0] || "");
      if (firstValue.startsWith("![[") || firstValue.startsWith("![](")) {
        if (!firstValue.startsWith('"') && !firstValue.endsWith('"')) {
          return `"${firstValue}"`;
        }
      }
      if (firstValue.startsWith('"') && firstValue.endsWith('"')) {
        const innerText = firstValue.slice(1, -1);
        const escapedInnerText = innerText.replace(/"/g, '\\"');
        return `"${escapedInnerText}"`;
      }
      return firstValue;
    }
    return value.filter((item) => item != null).map((item) => {
      const itemStr = String(item);
      if (itemStr.startsWith("![[") || itemStr.startsWith("![](")) {
        if (!itemStr.startsWith('"') && !itemStr.endsWith('"')) {
          return `"${itemStr}"`;
        }
      }
      if (itemStr.startsWith('"') && itemStr.endsWith('"')) {
        const innerText = itemStr.slice(1, -1);
        const escapedInnerText = innerText.replace(/"/g, '\\"');
        return `"${escapedInnerText}"`;
      }
      return itemStr;
    }).join(", ");
  }
  const stringValue = String(value || "");
  if (stringValue.startsWith('"') && stringValue.endsWith('"')) {
    const innerText = stringValue.slice(1, -1);
    const escapedInnerText = innerText.replace(/"/g, '\\"');
    return `"${escapedInnerText}"`;
  }
  return stringValue;
}
function replaceVariableSyntax(movieShow, text) {
  if (!(text == null ? void 0 : text.trim())) {
    return "";
  }
  try {
    const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
    const match = text.match(frontmatterRegex);
    if (match) {
      const [, frontmatter, body] = match;
      const processedFrontmatter = Object.entries(movieShow).reduce(
        (result2, [key, val = ""]) => {
          try {
            const quotedValue = getQuotedValueFromArray(val);
            return result2.replace(
              new RegExp(`{{${key}}}`, "ig"),
              quotedValue
            );
          } catch (error) {
            console.error(
              `Error processing frontmatter variable ${key}:`,
              error
            );
            return result2;
          }
        },
        frontmatter
      );
      const processedBody = Object.entries(movieShow).reduce(
        (result2, [key, val = ""]) => {
          try {
            const plainValue = getPlainValueFromArray(val);
            return result2.replace(
              new RegExp(`{{${key}}}`, "ig"),
              String(plainValue)
            );
          } catch (error) {
            console.error(
              `Error processing body variable ${key}:`,
              error
            );
            return result2;
          }
        },
        body
      );
      const result = `---
${processedFrontmatter}
---
${processedBody}`;
      return result.replace(/{{\w+}}/gi, "").trim();
    } else {
      const entries = Object.entries(movieShow);
      return entries.reduce((result, [key, val = ""]) => {
        try {
          const plainValue = getPlainValueFromArray(val);
          return result.replace(
            new RegExp(`{{${key}}}`, "ig"),
            String(plainValue)
          );
        } catch (error) {
          console.error(
            `Error processing variable ${key}:`,
            error
          );
          return result;
        }
      }, text).replace(/{{\w+}}/gi, "").trim();
    }
  } catch (error) {
    console.error("Error in replaceVariableSyntax:", error);
    return text;
  }
}
async function makeFileName(app, movieShow, fileNameFormat, folderPath) {
  try {
    let baseName;
    if (fileNameFormat) {
      baseName = replaceVariableSyntax(movieShow, fileNameFormat);
    } else {
      baseName = `${movieShow.nameForFile || t("utils.unknownMovie")} (${movieShow.year || t("utils.unknownMovie")})`;
    }
    const cleanedBaseName = replaceIllegalFileNameCharactersInString(baseName);
    if (!cleanedBaseName.trim()) {
      return `${t("utils.unknownMovie")}.md`;
    }
    const fileName = cleanedBaseName + ".md";
    const { vault } = app;
    const fullPath = folderPath ? `${folderPath}/${fileName}` : fileName;
    const normalizedPath = (0, import_obsidian.normalizePath)(fullPath);
    if (!vault.getAbstractFileByPath(normalizedPath)) {
      return fileName;
    }
    let copyNumber = 1;
    let copyFileName;
    let copyFullPath;
    do {
      copyFileName = `${cleanedBaseName} (${t(
        "utils.copyPrefix"
      )}[${copyNumber}]).md`;
      copyFullPath = folderPath ? `${folderPath}/${copyFileName}` : copyFileName;
      copyNumber++;
    } while (vault.getAbstractFileByPath((0, import_obsidian.normalizePath)(copyFullPath)));
    return copyFileName;
  } catch (error) {
    console.error("Error creating file name:", error);
    return `${t("utils.unknownMovie")}.md`;
  }
}
async function getTemplateContents(app, templatePath) {
  if (!templatePath || templatePath === "/") {
    return "";
  }
  try {
    const { metadataCache, vault } = app;
    const normalizedTemplatePath = (0, import_obsidian.normalizePath)(templatePath);
    const templateFile = metadataCache.getFirstLinkpathDest(
      normalizedTemplatePath,
      ""
    );
    if (!templateFile) {
      console.warn(
        `${t("utils.templateNotFound")}: ${normalizedTemplatePath}`
      );
      return "";
    }
    return await vault.cachedRead(templateFile);
  } catch (error) {
    console.error(`Failed to read the template '${templatePath}':`, error);
    new import_obsidian.Notice(t("utils.templateReadError"));
    return "";
  }
}

// APIProvider/DataFormatter.ts
var MAX_ARRAY_ITEMS = 50;
var MAX_FACTS_COUNT = 5;
var TYPE_TRANSLATIONS = {
  "animated-series": "\u0410\u043D\u0438\u043C\u0430\u0446\u0438\u043E\u043D\u043D\u044B\u0439 \u0441\u0435\u0440\u0438\u0430\u043B",
  anime: "\u0410\u043D\u0438\u043C\u0435",
  cartoon: "\u041C\u0443\u043B\u044C\u0442\u0444\u0438\u043B\u044C\u043C",
  movie: "\u0424\u0438\u043B\u044C\u043C",
  "tv-series": "\u0421\u0435\u0440\u0438\u0430\u043B"
};
var HTML_ENTITIES = {
  "&laquo;": "\xAB",
  "&raquo;": "\xBB",
  "&ldquo;": '"',
  "&rdquo;": '"',
  "&lsquo;": "'",
  "&rsquo;": "'",
  "&quot;": '"',
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&nbsp;": " ",
  "&ndash;": "\u2013",
  "&mdash;": "\u2014",
  "&hellip;": "\u2026"
};
var DataFormatter = class {
  /**
   * Set settings for path support
   */
  setSettings(settings) {
    this.settings = settings;
  }
  /**
   * Transforms API data into MovieShow format
   */
  createMovieShowFrom(fullInfo) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X;
    const seasonsData = this.calculateSeasonsData(fullInfo.seasonsInfo);
    const people = this.extractPeople(fullInfo.persons || []);
    const companies = this.extractCompanies(fullInfo);
    const facts = this.processFacts(fullInfo.facts || []);
    const names = this.processNames(fullInfo);
    const firstReleaseYear = (_a = fullInfo.releaseYears) == null ? void 0 : _a[0];
    const item = {
      // Basic information
      id: fullInfo.id,
      name: this.formatArray([fullInfo.name], "short" /* SHORT_VALUE */),
      alternativeName: this.formatArray(
        [fullInfo.alternativeName || ""],
        "short" /* SHORT_VALUE */
      ),
      year: fullInfo.year,
      description: this.formatArray(
        [fullInfo.description || ""],
        "long" /* LONG_TEXT */
      ),
      shortDescription: this.formatArray(
        [fullInfo.shortDescription || ""],
        "long" /* LONG_TEXT */
      ),
      // Additional properties for filenames
      nameForFile: this.cleanTextForMetadata(fullInfo.name),
      alternativeNameForFile: this.cleanTextForMetadata(
        fullInfo.alternativeName || ""
      ),
      enNameForFile: this.cleanTextForMetadata(fullInfo.enName || ""),
      // Images
      posterUrl: this.formatArray(
        [((_b = fullInfo.poster) == null ? void 0 : _b.url) || ""],
        "url" /* URL */
      ),
      coverUrl: this.formatArray(
        [((_c = fullInfo.backdrop) == null ? void 0 : _c.url) || ""],
        "url" /* URL */
      ),
      logoUrl: this.formatArray(
        [((_d = fullInfo.logo) == null ? void 0 : _d.url) || ""],
        "url" /* URL */
      ),
      // Ready-to-use image links for Obsidian
      posterMarkdown: this.createImageLink(((_e = fullInfo.poster) == null ? void 0 : _e.url) || ""),
      coverMarkdown: this.createImageLink(((_f = fullInfo.backdrop) == null ? void 0 : _f.url) || ""),
      logoMarkdown: this.createImageLink(((_g = fullInfo.logo) == null ? void 0 : _g.url) || ""),
      // Clean image paths for template sizing (filled by processImages())
      posterPath: [],
      coverPath: [],
      logoPath: [],
      // Classification
      genres: this.formatArray(
        fullInfo.genres.map((g) => capitalizeFirstLetter(g.name)),
        "short" /* SHORT_VALUE */
      ),
      genresLinks: this.formatArray(
        fullInfo.genres.map((g) => capitalizeFirstLetter(g.name)),
        "link" /* LINK */
      ),
      countries: this.formatArray(
        fullInfo.countries.map((c) => c.name),
        "short" /* SHORT_VALUE */
      ),
      countriesLinks: this.formatArray(
        fullInfo.countries.map((c) => c.name),
        "link" /* LINK */
      ),
      type: this.formatArray(
        [this.translateType(fullInfo.type || "")],
        "short" /* SHORT_VALUE */
      ),
      subType: this.formatArray(
        [fullInfo.subType || ""],
        "short" /* SHORT_VALUE */
      ),
      // People
      director: this.formatArray(people.directors, "short" /* SHORT_VALUE */),
      directorsLinks: this.formatArray(people.directors, "link" /* LINK */),
      directorsLinksWithPath: this.formatArray(
        people.directors,
        "link_with_path" /* LINK_WITH_PATH */,
        (_h = this.settings) == null ? void 0 : _h.directorsPath
      ),
      directorsIdsWithPath: this.formatArray(
        people.directors,
        "link_id_with_path" /* LINK_ID_WITH_PATH */,
        (_i = this.settings) == null ? void 0 : _i.directorsPath
      ),
      actors: this.formatArray(people.actors, "short" /* SHORT_VALUE */),
      actorsLinks: this.formatArray(people.actors, "link" /* LINK */),
      actorsLinksWithPath: this.formatArray(
        people.actors,
        "link_with_path" /* LINK_WITH_PATH */,
        (_j = this.settings) == null ? void 0 : _j.actorsPath
      ),
      actorsIdsWithPath: this.formatArray(
        people.actors,
        "link_id_with_path" /* LINK_ID_WITH_PATH */,
        (_k = this.settings) == null ? void 0 : _k.actorsPath
      ),
      writers: this.formatArray(people.writers, "short" /* SHORT_VALUE */),
      writersLinks: this.formatArray(people.writers, "link" /* LINK */),
      writersLinksWithPath: this.formatArray(
        people.writers,
        "link_with_path" /* LINK_WITH_PATH */,
        (_l = this.settings) == null ? void 0 : _l.writersPath
      ),
      writersIdsWithPath: this.formatArray(
        people.writers,
        "link_id_with_path" /* LINK_ID_WITH_PATH */,
        (_m = this.settings) == null ? void 0 : _m.writersPath
      ),
      producers: this.formatArray(people.producers, "short" /* SHORT_VALUE */),
      producersLinks: this.formatArray(people.producers, "link" /* LINK */),
      producersLinksWithPath: this.formatArray(
        people.producers,
        "link_with_path" /* LINK_WITH_PATH */,
        (_n = this.settings) == null ? void 0 : _n.producersPath
      ),
      producersIdsWithPath: this.formatArray(
        people.producers,
        "link_id_with_path" /* LINK_ID_WITH_PATH */,
        (_o = this.settings) == null ? void 0 : _o.producersPath
      ),
      // Technical specifications
      movieLength: fullInfo.movieLength || 0,
      isSeries: fullInfo.isSeries,
      seriesLength: fullInfo.seriesLength || 0,
      totalSeriesLength: fullInfo.totalSeriesLength || 0,
      isComplete: (fullInfo.status || "") === "completed",
      seasonsCount: seasonsData.count,
      seriesInSeasonCount: seasonsData.averageEpisodesPerSeason,
      // Ratings and votes
      ratingKp: ((_p = fullInfo.rating) == null ? void 0 : _p.kp) ? Number((_r = (_q = fullInfo.rating) == null ? void 0 : _q.kp) == null ? void 0 : _r.toFixed(0)) : 0,
      ratingImdb: fullInfo.rating ? Number((_t = (_s = fullInfo.rating) == null ? void 0 : _s.imdb) == null ? void 0 : _t.toFixed(0)) : 0,
      ratingFilmCritics: ((_u = fullInfo.rating) == null ? void 0 : _u.filmCritics) || 0,
      ratingRussianFilmCritics: ((_v = fullInfo.rating) == null ? void 0 : _v.russianFilmCritics) || 0,
      votesKp: ((_w = fullInfo.votes) == null ? void 0 : _w.kp) || 0,
      votesImdb: ((_x = fullInfo.votes) == null ? void 0 : _x.imdb) || 0,
      votesFilmCritics: ((_y = fullInfo.votes) == null ? void 0 : _y.filmCritics) || 0,
      votesRussianFilmCritics: ((_z = fullInfo.votes) == null ? void 0 : _z.russianFilmCritics) || 0,
      // External IDs and links
      kinopoiskUrl: this.formatArray(
        [`https://www.kinopoisk.ru/film/${fullInfo.id}/`],
        "url" /* URL */
      ),
      imdbId: this.formatArray(
        [((_A = fullInfo.externalId) == null ? void 0 : _A.imdb) || ""],
        "short" /* SHORT_VALUE */
      ),
      tmdbId: ((_B = fullInfo.externalId) == null ? void 0 : _B.tmdb) || 0,
      kpHDId: this.formatArray(
        [((_C = fullInfo.externalId) == null ? void 0 : _C.kpHD) || ""],
        "short" /* SHORT_VALUE */
      ),
      // Additional information
      slogan: this.formatArray(
        [fullInfo.slogan || ""],
        "long" /* LONG_TEXT */
      ),
      ageRating: fullInfo.ageRating || 0,
      ratingMpaa: this.formatArray(
        [fullInfo.ratingMpaa || ""],
        "short" /* SHORT_VALUE */
      ),
      // Financial data
      budgetValue: ((_D = fullInfo.budget) == null ? void 0 : _D.value) || 0,
      budgetCurrency: this.formatArray(
        [((_E = fullInfo.budget) == null ? void 0 : _E.currency) || ""],
        "short" /* SHORT_VALUE */
      ),
      feesWorldValue: ((_G = (_F = fullInfo.fees) == null ? void 0 : _F.world) == null ? void 0 : _G.value) || 0,
      feesWorldCurrency: this.formatArray(
        [((_I = (_H = fullInfo.fees) == null ? void 0 : _H.world) == null ? void 0 : _I.currency) || ""],
        "short" /* SHORT_VALUE */
      ),
      feesRussiaValue: ((_K = (_J = fullInfo.fees) == null ? void 0 : _J.russia) == null ? void 0 : _K.value) || 0,
      feesRussiaCurrency: this.formatArray(
        [((_M = (_L = fullInfo.fees) == null ? void 0 : _L.russia) == null ? void 0 : _M.currency) || ""],
        "short" /* SHORT_VALUE */
      ),
      feesUsaValue: ((_O = (_N = fullInfo.fees) == null ? void 0 : _N.usa) == null ? void 0 : _O.value) || 0,
      feesUsaCurrency: this.formatArray(
        [((_Q = (_P = fullInfo.fees) == null ? void 0 : _P.usa) == null ? void 0 : _Q.currency) || ""],
        "short" /* SHORT_VALUE */
      ),
      // Premiere dates
      premiereWorld: this.formatArray(
        [this.formatDate((_R = fullInfo.premiere) == null ? void 0 : _R.world)],
        "short" /* SHORT_VALUE */
      ),
      premiereRussia: this.formatArray(
        [this.formatDate((_S = fullInfo.premiere) == null ? void 0 : _S.russia)],
        "short" /* SHORT_VALUE */
      ),
      premiereDigital: this.formatArray(
        [this.formatDate((_T = fullInfo.premiere) == null ? void 0 : _T.digital)],
        "short" /* SHORT_VALUE */
      ),
      premiereCinema: this.formatArray(
        [this.formatDate((_U = fullInfo.premiere) == null ? void 0 : _U.cinema)],
        "short" /* SHORT_VALUE */
      ),
      // Release years
      releaseYearsStart: (firstReleaseYear == null ? void 0 : firstReleaseYear.start) || 0,
      releaseYearsEnd: (firstReleaseYear == null ? void 0 : firstReleaseYear.end) || 0,
      // Top ratings
      top10: fullInfo.top10 || 0,
      top250: fullInfo.top250 || 0,
      // Facts
      facts: this.formatArray(facts, "long" /* LONG_TEXT */),
      // Alternative names
      allNamesString: this.formatArray(
        names.allNames,
        "short" /* SHORT_VALUE */
      ),
      enName: this.formatArray(
        [fullInfo.enName || ""],
        "short" /* SHORT_VALUE */
      ),
      // Networks and companies
      networks: this.formatArray(
        companies.networks,
        "short" /* SHORT_VALUE */
      ),
      networksLinks: this.formatArray(
        companies.networks,
        "link" /* LINK */
      ),
      productionCompanies: this.formatArray(
        companies.productionCompanies,
        "short" /* SHORT_VALUE */
      ),
      productionCompaniesLinks: this.formatArray(
        companies.productionCompanies,
        "link" /* LINK */
      ),
      // Distributors
      distributor: this.formatArray(
        [((_V = fullInfo.distributors) == null ? void 0 : _V.distributor) || ""],
        "short" /* SHORT_VALUE */
      ),
      distributorRelease: this.formatArray(
        [
          this.formatDate(
            (_W = fullInfo.distributors) == null ? void 0 : _W.distributorRelease
          ) || ((_X = fullInfo.distributors) == null ? void 0 : _X.distributorRelease) || ""
        ],
        "short" /* SHORT_VALUE */
      ),
      // Related movies/series
      sequelsAndPrequels: this.formatArray(
        companies.sequelsAndPrequels,
        "short" /* SHORT_VALUE */
      ),
      sequelsAndPrequelsLinks: this.formatArray(
        companies.sequelsAndPrequels,
        "link" /* LINK */
      )
    };
    return item;
  }
  /**
   * Universal array formatting based on type
   */
  formatArray(items, formatType, folderPath, maxItems = MAX_ARRAY_ITEMS) {
    if (formatType === "link_id_with_path" /* LINK_ID_WITH_PATH */) {
      const personItems = items;
      return personItems.filter((item) => item.name && item.name.trim() !== "").slice(0, maxItems).map((item) => {
        const cleanName = this.cleanTextForMetadata(item.name);
        if (folderPath && folderPath.trim() !== "" && item.id) {
          return `"[[${folderPath}/${item.id}|${cleanName}]]"`;
        } else if (item.id) {
          return `"[[${item.id}|${cleanName}]]"`;
        }
        return `"[[${cleanName}]]"`;
      });
    }
    const stringItems = items.map(
      (item) => typeof item === "object" && item.name ? item.name : item
    );
    const filteredItems = stringItems.filter((item) => typeof item === "string" && item.trim() !== "").slice(0, maxItems);
    switch (formatType) {
      case "short" /* SHORT_VALUE */:
        return filteredItems.map(
          (item) => this.cleanTextForMetadata(item)
        );
      case "long" /* LONG_TEXT */:
        return filteredItems.map((item) => {
          const cleanedItem = item.replace(/\n/g, " ").replace(/\s+/g, " ").trim();
          return `"${cleanedItem}"`;
        });
      case "url" /* URL */:
        return filteredItems.map((item) => item.trim());
      case "link" /* LINK */:
        return filteredItems.map((item) => {
          const cleanName = this.cleanTextForMetadata(item);
          return `"[[${cleanName}]]"`;
        });
      case "link_with_path" /* LINK_WITH_PATH */:
        return filteredItems.map((item) => {
          const cleanName = this.cleanTextForMetadata(item);
          if (folderPath && folderPath.trim() !== "") {
            return `"[[${folderPath}/${cleanName}]]"`;
          }
          return `"[[${cleanName}]]"`;
        });
      default:
        return filteredItems;
    }
  }
  /**
   * Calculates seasons data from seasons info
   */
  calculateSeasonsData(seasonsInfo) {
    if (!seasonsInfo || seasonsInfo.length === 0) {
      return { count: 0, averageEpisodesPerSeason: 0 };
    }
    const totalEpisodes = seasonsInfo.reduce(
      (total, season) => total + season.episodesCount,
      0
    );
    const averageEpisodes = Math.ceil(totalEpisodes / seasonsInfo.length);
    return {
      count: seasonsInfo.length,
      averageEpisodesPerSeason: averageEpisodes
    };
  }
  /**
   * Extracts people by profession from persons array
   */
  /**
  * Extracts people by profession from persons array
  */
  extractPeople(persons) {
    const result = {
      directors: [],
      actors: [],
      writers: [],
      producers: []
    };
    for (const person of persons) {
      if (!person.name || !person.enProfession) continue;
      const personData = { name: person.name, id: person.id };
      switch (person.enProfession) {
        case "director":
          result.directors.push(personData);
          break;
        case "actor":
          result.actors.push(personData);
          break;
        case "writer":
          result.writers.push(personData);
          break;
        case "producer":
          result.producers.push(personData);
          break;
      }
    }
    return result;
  }
  /**
  * Extracts IDs from person objects
  */
  extractPersonIds(persons) {
    return persons.map((person) => person.id).filter((id) => id !== void 0);
  }
  /**
   * Extracts companies and related movies from API response
   */
  extractCompanies(fullInfo) {
    var _a, _b, _c, _d;
    const networks = ((_b = (_a = fullInfo.networks) == null ? void 0 : _a.items) == null ? void 0 : _b.map((network) => network.name).filter((name) => name && name.trim() !== "")) || [];
    const productionCompanies = ((_c = fullInfo.productionCompanies) == null ? void 0 : _c.map((company) => company.name).filter((name) => name && name.trim() !== "")) || [];
    const sequelsAndPrequels = ((_d = fullInfo.sequelsAndPrequels) == null ? void 0 : _d.map((movie) => movie.name).filter((name) => name && name.trim() !== "")) || [];
    return { networks, productionCompanies, sequelsAndPrequels };
  }
  /**
   * Processes facts by removing spoilers and HTML tags
   */
  processFacts(facts) {
    return facts.filter(
      (fact) => !fact.spoiler && fact.value && fact.value.trim() !== ""
    ).slice(0, MAX_FACTS_COUNT).map((fact) => this.stripHtmlTags(fact.value));
  }
  processNames(fullInfo) {
    var _a;
    const allNames = ((_a = fullInfo.names) == null ? void 0 : _a.map((nameObj) => nameObj.name).filter((name) => name && name.trim() !== "")) || [];
    return { allNames };
  }
  /**
   * Formats date to Obsidian format (YYYY-MM-DD)
   */
  formatDate(dateString) {
    if (!dateString) return "";
    try {
      const date = new Date(dateString);
      if (isNaN(date.getTime()) || date.getFullYear() < 1800 || date.getFullYear() > 2100) {
        return "";
      }
      return date.toISOString().split("T")[0];
    } catch (e) {
      return "";
    }
  }
  /**
   * Cleans text from characters that might break metadata
   */
  cleanTextForMetadata(text) {
    if (!text) return "";
    return text.replace(/:/g, "").trim();
  }
  /**
   * Creates image link for Obsidian format
   */
  createImageLink(imagePath) {
    if (!imagePath || imagePath.trim() === "") return [];
    if (!imagePath.startsWith("http")) {
      return [`![[${imagePath}]]`];
    }
    return [`![](${imagePath})`];
  }
  translateType(type) {
    return TYPE_TRANSLATIONS[type] || type;
  }
  /**
   * Removes HTML tags and decodes HTML entities
   */
  stripHtmlTags(text) {
    let cleanText = text.replace(/<[^>]*>/g, "");
    for (const [entity, char] of Object.entries(HTML_ENTITIES)) {
      cleanText = cleanText.replace(new RegExp(entity, "g"), char);
    }
    cleanText = cleanText.replace(/&#?\w+;/g, "");
    return cleanText.trim();
  }
};

// APIProvider/ApiValidator.ts
var MIN_QUERY_LENGTH = 1;
var MAX_QUERY_LENGTH = 200;
var MIN_TOKEN_LENGTH = 10;
var MAX_TOKEN_LENGTH = 100;
var MIN_MOVIE_ID = 1;
var MAX_MOVIE_ID = 99999999;
var ApiValidator = class {
  /**
   * Validates API token format and length
   */
  isValidToken(token) {
    if (typeof token !== "string") {
      return false;
    }
    const trimmedToken = token.trim();
    if (!trimmedToken) {
      return false;
    }
    if (trimmedToken.length < MIN_TOKEN_LENGTH || trimmedToken.length > MAX_TOKEN_LENGTH) {
      return false;
    }
    const tokenPattern = /^[A-Za-z0-9\-_]+$/;
    if (!tokenPattern.test(trimmedToken)) {
      return false;
    }
    return true;
  }
  /**
   * Validates search query for safety and length
   */
  isValidSearchQuery(query) {
    if (typeof query !== "string") {
      return false;
    }
    const trimmedQuery = query.trim();
    if (!trimmedQuery) {
      return false;
    }
    if (trimmedQuery.length < MIN_QUERY_LENGTH || trimmedQuery.length > MAX_QUERY_LENGTH) {
      return false;
    }
    const suspiciousPatterns = [
      /<script/i,
      /javascript:/i,
      /on\w+=/i,
      /<%/,
      /%>/
    ];
    if (suspiciousPatterns.some((pattern) => pattern.test(trimmedQuery))) {
      return false;
    }
    return true;
  }
  /**
   * Validates movie ID range and type
   */
  isValidMovieId(id) {
    if (typeof id !== "number") {
      return false;
    }
    if (!Number.isFinite(id)) {
      return false;
    }
    if (id < MIN_MOVIE_ID || id > MAX_MOVIE_ID) {
      return false;
    }
    if (!Number.isInteger(id)) {
      return false;
    }
    return true;
  }
  /**
   * Validates pagination parameters
   */
  isValidPaginationParams(page, limit) {
    if (page !== void 0) {
      if (!Number.isInteger(page) || page < 1 || page > 1e3) {
        return false;
      }
    }
    if (limit !== void 0) {
      if (!Number.isInteger(limit) || limit < 1 || limit > 250) {
        return false;
      }
    }
    return true;
  }
  /**
   * Sanitizes search query by removing dangerous characters
   */
  sanitizeQuery(query) {
    return query.trim().replace(/\s+/g, " ").replace(/[<>]/g, "").substring(0, MAX_QUERY_LENGTH);
  }
  /**
   * Sanitizes token by keeping only allowed characters
   */
  sanitizeToken(token) {
    return token.trim().replace(/[^A-Za-z0-9\-_]/g, "").substring(0, MAX_TOKEN_LENGTH);
  }
  /**
   * Validates complete request configuration
   */
  validateRequestConfig(config) {
    const errors = [];
    if (!this.isValidToken(config.token)) {
      errors.push(t("validation.invalidApiToken"));
    }
    if (config.query !== void 0 && !this.isValidSearchQuery(config.query)) {
      errors.push(t("validation.invalidSearchQuery"));
    }
    if (config.movieId !== void 0 && !this.isValidMovieId(config.movieId)) {
      errors.push(t("validation.invalidMovieId"));
    }
    if (!this.isValidPaginationParams(config.page, config.limit)) {
      errors.push(t("validation.invalidPaginationParams"));
    }
    return {
      isValid: errors.length === 0,
      errors
    };
  }
};

// APIProvider/provider.ts
var API_BASE_URL = "https://api.kinopoisk.dev/v1.4";
var MAX_SEARCH_RESULTS = 50;
var KinopoiskProvider = class {
  constructor(settings) {
    this.errorHandler = new ErrorHandler();
    this.dataFormatter = new DataFormatter();
    this.validator = new ApiValidator();
    if (settings) {
      this.dataFormatter.setSettings(settings);
    }
  }
  /**
   * Performs HTTP GET request to API
   */
  async apiGet(endpoint, token, params = {}, headers) {
    if (!this.validator.isValidToken(token)) {
      throw new Error(t("provider.tokenRequired"));
    }
    const url = this.buildUrl(endpoint, params);
    try {
      const res = await (0, import_obsidian2.requestUrl)({
        url,
        method: "GET",
        headers: {
          Accept: "*/*",
          "X-API-KEY": token.trim(),
          ...headers
        }
      });
      return res.json;
    } catch (error) {
      throw this.errorHandler.handleApiError(error);
    }
  }
  /**
   * Builds URL with query parameters
   */
  buildUrl(endpoint, params) {
    const url = new URL(`${API_BASE_URL}${endpoint}`);
    for (const [key, value] of Object.entries(params)) {
      if (value !== void 0 && value !== null && value !== "") {
        url.searchParams.set(key, value.toString());
      }
    }
    return url.href;
  }
  /**
   * Search for movies and TV shows by query
   */
  async searchByQuery(query, token) {
    if (!this.validator.isValidSearchQuery(query)) {
      throw new Error(t("provider.enterMovieTitle"));
    }
    const searchResults = await this.apiGet(
      "/movie/search",
      token,
      {
        query: query.trim(),
        limit: MAX_SEARCH_RESULTS
      }
    );
    if (!searchResults.docs || searchResults.docs.length === 0) {
      throw new Error(
        tWithParams("provider.nothingFound", { query }) + " " + t("provider.tryChangeQuery")
      );
    }
    return searchResults.docs;
  }
  /**
   * Retrieves detailed movie/TV show information by ID
   */
  async getMovieById(id, token) {
    if (!this.validator.isValidMovieId(id)) {
      throw new Error(t("provider.invalidMovieId"));
    }
    if (!this.validator.isValidToken(token)) {
      throw new Error(t("provider.tokenRequiredForMovie"));
    }
    const movieData = await this.apiGet(
      `/movie/${id}`,
      token
    );
    if (!movieData) {
      throw new Error(t("provider.movieInfoError"));
    }
    const movieShow = this.dataFormatter.createMovieShowFrom(movieData);
    return movieShow;
  }
  /**
   * Validates API token by making test request
   */
  async validateToken(token) {
    if (!this.validator.isValidToken(token)) {
      return false;
    }
    try {
      await this.apiGet("/movie", token, {
        page: 1,
        limit: 1
      });
      return true;
    } catch (e) {
      return false;
    }
  }
};
var provider = new KinopoiskProvider();

// Views/search_modal.ts
var SearchModal = class extends import_obsidian3.Modal {
  constructor(plugin, callback) {
    super(plugin.app);
    this.callback = callback;
    this.isBusy = false;
    this.query = "";
    this.token = "";
    // Enter key handler for search
    this.submitEnterCallback = (event) => {
      if (event.key === "Enter" && !event.isComposing) {
        this.search();
      }
    };
    this.token = plugin.settings.apiToken;
    this.kinopoiskProvider = new KinopoiskProvider({
      actorsPath: plugin.settings.actorsPath,
      directorsPath: plugin.settings.directorsPath,
      writersPath: plugin.settings.writersPath,
      producersPath: plugin.settings.producersPath
    });
  }
  // Manages UI loading state
  setBusy(busy) {
    var _a, _b, _c;
    this.isBusy = busy;
    (_a = this.okBtnRef) == null ? void 0 : _a.setDisabled(busy);
    (_b = this.okBtnRef) == null ? void 0 : _b.setButtonText(
      busy ? t("modals.searching") : t("modals.searchButton")
    );
    (_c = this.inputRef) == null ? void 0 : _c.setDisabled(busy);
  }
  // Validates input before search
  validateInput() {
    var _a, _b;
    if (!((_a = this.query) == null ? void 0 : _a.trim())) {
      new import_obsidian3.Notice(t("modals.enterMovieName"));
      return false;
    }
    if (!((_b = this.token) == null ? void 0 : _b.trim())) {
      new import_obsidian3.Notice(t("modals.needApiToken"));
      return false;
    }
    if (this.isBusy) {
      return false;
    }
    return true;
  }
  // Handles search errors
  handleSearchError(error) {
    const errorMessage = error instanceof Error ? error.message : t("modals.errorUnexpected");
    new import_obsidian3.Notice(errorMessage);
    this.callback(error);
  }
  // Performs search via Kinopoisk API
  async search() {
    if (!this.validateInput()) {
      return;
    }
    try {
      this.setBusy(true);
      const searchResults = await this.kinopoiskProvider.searchByQuery(
        this.query.trim(),
        this.token
      );
      this.callback(null, searchResults);
      this.close();
    } catch (error) {
      this.handleSearchError(error);
    } finally {
      this.setBusy(false);
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: t("modals.searchTitle") });
    contentEl.createDiv(
      { cls: "kinopoisk-plugin__search-modal--input" },
      (settingItem) => {
        this.inputRef = new import_obsidian3.TextComponent(settingItem).setValue(this.query).setPlaceholder(t("modals.searchPlaceholder")).onChange((value) => this.query = value);
        this.inputRef.inputEl.addEventListener(
          "keydown",
          this.submitEnterCallback
        );
      }
    );
    new import_obsidian3.Setting(contentEl).addButton((btn) => {
      return this.okBtnRef = btn.setButtonText(t("modals.searchButton")).setCta().onClick(() => {
        this.search();
      });
    });
  }
  onClose() {
    var _a;
    if ((_a = this.inputRef) == null ? void 0 : _a.inputEl) {
      this.inputRef.inputEl.removeEventListener(
        "keydown",
        this.submitEnterCallback
      );
    }
    this.contentEl.empty();
  }
};

// Views/suggest_modal.ts
var import_obsidian5 = require("obsidian");

// Utils/imageUtils.ts
var import_obsidian4 = require("obsidian");
var DOWNLOAD_CONFIG = {
  timeout: 1e4,
  // 10 seconds timeout
  maxRetries: 2,
  // maximum 2 attempts
  retryDelay: 1e3
  // delay between attempts in ms
};
var SUPPORTED_EXTENSIONS = [
  "jpg",
  "jpeg",
  "png",
  "gif",
  "webp",
  "svg",
  "bmp"
];
var MIME_TO_EXTENSION_MAP = {
  "image/jpeg": "jpg",
  "image/jpg": "jpg",
  "image/png": "png",
  "image/gif": "gif",
  "image/webp": "webp",
  "image/svg+xml": "svg",
  "image/bmp": "bmp"
};
function isValidImageUrl(url) {
  if (!url || url.trim() === "") return false;
  try {
    new URL(url);
    return url.startsWith("http://") || url.startsWith("https://");
  } catch (e) {
    return false;
  }
}
function getImageExtension(url, mimeType) {
  var _a;
  if (mimeType && MIME_TO_EXTENSION_MAP[mimeType]) {
    return MIME_TO_EXTENSION_MAP[mimeType];
  }
  const urlExtension = (_a = url.split(".").pop()) == null ? void 0 : _a.toLowerCase();
  if (urlExtension && SUPPORTED_EXTENSIONS.includes(urlExtension)) {
    return urlExtension;
  }
  return "jpg";
}
function createImageFileName(movieShow, imageType, extension) {
  const baseName = `${movieShow.nameForFile}_${movieShow.year}_${imageType}`;
  const cleanedBaseName = replaceIllegalFileNameCharactersInString(baseName);
  return `${cleanedBaseName}.${extension}`;
}
function extractCleanPath(imagePath) {
  if (!imagePath || imagePath.trim() === "") return "";
  if (!imagePath.startsWith("http")) {
    return imagePath.split("/").pop() || imagePath;
  }
  return imagePath;
}
function isNetworkError(error) {
  if (!error || typeof error !== "object" || typeof error.message !== "string") {
    return false;
  }
  const networkErrors = [
    "ERR_CONNECTION_TIMED_OUT",
    "ERR_NETWORK_CHANGED",
    "ERR_INTERNET_DISCONNECTED",
    "ERR_NAME_NOT_RESOLVED",
    "ERR_CONNECTION_REFUSED",
    "ERR_CONNECTION_RESET",
    "ERR_BLOCKED_BY_CLIENT"
  ];
  return networkErrors.some(
    (errorCode) => error.message.includes(errorCode)
  );
}
function withTimeout(promise, timeoutMs) {
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(
        new Error(tWithParams("images.timeout", { timeout: timeoutMs }))
      );
    }, timeoutMs);
  });
  return Promise.race([promise, timeoutPromise]);
}
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function downloadImage(url) {
  if (!isValidImageUrl(url)) {
    throw new Error(tWithParams("images.invalidUrl", { url }));
  }
  let lastError = new Error(
    tWithParams("images.downloadFailed", { url })
  );
  for (let attempt = 1; attempt <= DOWNLOAD_CONFIG.maxRetries; attempt++) {
    try {
      const downloadPromise = (0, import_obsidian4.requestUrl)({
        url,
        method: "GET"
      });
      const response = await withTimeout(
        downloadPromise,
        DOWNLOAD_CONFIG.timeout
      );
      if (response.status !== 200) {
        if (response.status === 404) {
          throw new Error(
            tWithParams("images.imageNotFound", { url })
          );
        } else if (response.status === 403) {
          throw new Error(
            tWithParams("images.accessForbidden", { url })
          );
        } else if (response.status >= 500) {
          throw new Error(
            tWithParams("images.serverError", {
              status: response.status,
              url
            })
          );
        } else {
          throw new Error(
            tWithParams("images.httpError", {
              status: response.status,
              url
            })
          );
        }
      }
      return {
        data: response.arrayBuffer,
        mimeType: response.headers["content-type"]
      };
    } catch (error) {
      lastError = error;
      console.warn(
        `Failed to download image (attempt ${attempt}/${DOWNLOAD_CONFIG.maxRetries}): ${url}`,
        error
      );
      if (attempt === DOWNLOAD_CONFIG.maxRetries || !isNetworkError(error)) {
        break;
      }
      if (attempt < DOWNLOAD_CONFIG.maxRetries) {
        await delay(DOWNLOAD_CONFIG.retryDelay);
      }
    }
  }
  console.error(
    `Failed to download image after ${DOWNLOAD_CONFIG.maxRetries} attempts: ${url}`,
    lastError
  );
  throw lastError;
}
async function saveImageToVault(app, imageData, folderPath, fileName) {
  const { vault } = app;
  const normalizedFolderPath = (0, import_obsidian4.normalizePath)(folderPath);
  if (!vault.getAbstractFileByPath(normalizedFolderPath)) {
    await vault.createFolder(normalizedFolderPath);
  }
  const fullPath = (0, import_obsidian4.normalizePath)(`${folderPath}/${fileName}`);
  let finalPath = fullPath;
  let counter = 1;
  while (vault.getAbstractFileByPath(finalPath)) {
    const pathParts = fullPath.split(".");
    const extension = pathParts.pop();
    const basePath = pathParts.join(".");
    finalPath = `${basePath}_${counter}.${extension}`;
    counter++;
  }
  await vault.createBinary(finalPath, imageData);
  return finalPath;
}
async function downloadAndSaveImage(app, url, movieShow, imageType, folderPath) {
  try {
    if (!isValidImageUrl(url)) {
      return url;
    }
    const { data, mimeType } = await downloadImage(url);
    const extension = getImageExtension(url, mimeType);
    const fileName = createImageFileName(movieShow, imageType, extension);
    const localPath = await saveImageToVault(
      app,
      data,
      folderPath,
      fileName
    );
    return localPath;
  } catch (error) {
    console.error(`Failed to download and save image: ${url}`, error);
    throw error;
  }
}
function createImageLink(imagePath) {
  if (!imagePath || imagePath.trim() === "") return [];
  if (!imagePath.startsWith("http")) {
    const fileName = imagePath.split("/").pop() || imagePath;
    return [`![[${fileName}]]`];
  }
  return [`![](${imagePath})`];
}
function countImagesToDownload(movieShow, settings) {
  let count = 0;
  if (settings.savePosterImage && movieShow.posterUrl.length > 0 && movieShow.posterUrl[0] && isValidImageUrl(movieShow.posterUrl[0])) {
    count++;
  }
  if (settings.saveCoverImage && movieShow.coverUrl.length > 0 && movieShow.coverUrl[0] && isValidImageUrl(movieShow.coverUrl[0])) {
    count++;
  }
  if (settings.saveLogoImage && movieShow.logoUrl.length > 0 && movieShow.logoUrl[0] && isValidImageUrl(movieShow.logoUrl[0])) {
    count++;
  }
  return count;
}
function getImageTypeDisplayName(imageType) {
  return t(`images.${imageType}`);
}
async function processImages(app, movieShow, settings, progressCallback) {
  if (!settings.saveImagesLocally) {
    return movieShow;
  }
  const updatedMovieShow = { ...movieShow };
  const totalImages = countImagesToDownload(movieShow, settings);
  let processedImages = 0;
  let successfulDownloads = 0;
  let failedDownloads = 0;
  if (totalImages === 0) {
    progressCallback == null ? void 0 : progressCallback(0, 0, t("images.noImagesToDownload"));
    return movieShow;
  }
  try {
    if (settings.savePosterImage && movieShow.posterUrl.length > 0 && movieShow.posterUrl[0]) {
      const posterUrl = movieShow.posterUrl[0];
      if (isValidImageUrl(posterUrl)) {
        const imageTypeName = getImageTypeDisplayName("poster");
        progressCallback == null ? void 0 : progressCallback(
          processedImages + 1,
          totalImages,
          `${t("images.downloading")} ${imageTypeName}...`
        );
        try {
          const localPath = await downloadAndSaveImage(
            app,
            posterUrl,
            movieShow,
            "poster",
            settings.imagesFolder
          );
          updatedMovieShow.posterMarkdown = createImageLink(localPath);
          updatedMovieShow.posterPath = [extractCleanPath(localPath)];
          processedImages++;
          successfulDownloads++;
        } catch (error) {
          console.warn("Failed to download poster image:", error);
          processedImages++;
          failedDownloads++;
          if (isNetworkError(error)) {
            console.warn(t("images.posterUnavailable"));
          } else {
            console.warn(
              `${t("images.downloadError")} ${t("images.poster")}`
            );
          }
          updatedMovieShow.posterMarkdown = createImageLink(posterUrl);
          updatedMovieShow.posterPath = [extractCleanPath(posterUrl)];
        }
      } else {
        updatedMovieShow.posterMarkdown = createImageLink(posterUrl);
        updatedMovieShow.posterPath = [extractCleanPath(posterUrl)];
      }
    }
    if (settings.saveCoverImage && movieShow.coverUrl.length > 0 && movieShow.coverUrl[0]) {
      const coverUrl = movieShow.coverUrl[0];
      if (isValidImageUrl(coverUrl)) {
        const imageTypeName = getImageTypeDisplayName("cover");
        progressCallback == null ? void 0 : progressCallback(
          processedImages + 1,
          totalImages,
          `${t("images.downloading")} ${imageTypeName}...`
        );
        try {
          const localPath = await downloadAndSaveImage(
            app,
            coverUrl,
            movieShow,
            "cover",
            settings.imagesFolder
          );
          updatedMovieShow.coverMarkdown = createImageLink(localPath);
          updatedMovieShow.coverPath = [extractCleanPath(localPath)];
          processedImages++;
          successfulDownloads++;
        } catch (error) {
          console.warn("Failed to download cover image:", error);
          processedImages++;
          failedDownloads++;
          if (isNetworkError(error)) {
            console.warn(t("images.coverUnavailable"));
          } else {
            console.warn(
              `${t("images.downloadError")} ${t("images.cover")}`
            );
          }
          updatedMovieShow.coverMarkdown = createImageLink(coverUrl);
          updatedMovieShow.coverPath = [extractCleanPath(coverUrl)];
        }
      } else {
        updatedMovieShow.coverMarkdown = createImageLink(coverUrl);
        updatedMovieShow.coverPath = [extractCleanPath(coverUrl)];
      }
    }
    if (settings.saveLogoImage && movieShow.logoUrl.length > 0 && movieShow.logoUrl[0]) {
      const logoUrl = movieShow.logoUrl[0];
      if (isValidImageUrl(logoUrl)) {
        const imageTypeName = getImageTypeDisplayName("logo");
        progressCallback == null ? void 0 : progressCallback(
          processedImages + 1,
          totalImages,
          `${t("images.downloading")} ${imageTypeName}...`
        );
        try {
          const localPath = await downloadAndSaveImage(
            app,
            logoUrl,
            movieShow,
            "logo",
            settings.imagesFolder
          );
          updatedMovieShow.logoMarkdown = createImageLink(localPath);
          updatedMovieShow.logoPath = [extractCleanPath(localPath)];
          processedImages++;
          successfulDownloads++;
        } catch (error) {
          console.warn("Failed to download logo image:", error);
          processedImages++;
          failedDownloads++;
          if (isNetworkError(error)) {
            console.warn(t("images.logoUnavailable"));
          } else {
            console.warn(
              `${t("images.downloadError")} ${t("images.logo")}`
            );
          }
          updatedMovieShow.logoMarkdown = createImageLink(logoUrl);
          updatedMovieShow.logoPath = [extractCleanPath(logoUrl)];
        }
      } else {
        updatedMovieShow.logoMarkdown = createImageLink(logoUrl);
        updatedMovieShow.logoPath = [extractCleanPath(logoUrl)];
      }
    }
    if (progressCallback) {
      if (failedDownloads > 0) {
        progressCallback(
          totalImages,
          totalImages,
          tWithParams("images.completedWithErrors", {
            successful: successfulDownloads,
            failed: failedDownloads
          })
        );
      } else if (successfulDownloads > 0) {
        progressCallback(
          totalImages,
          totalImages,
          t("images.completedAllDownloaded")
        );
      } else {
        progressCallback(
          totalImages,
          totalImages,
          t("images.completedAlreadyLocal")
        );
      }
    }
    if (failedDownloads > 0) {
      if (successfulDownloads > 0) {
        new import_obsidian4.Notice(
          tWithParams("images.downloadedWithErrors", {
            successful: successfulDownloads,
            total: totalImages
          })
        );
      } else {
        new import_obsidian4.Notice(t("images.imagesUnavailable"));
      }
    }
  } catch (error) {
    console.error("Error processing images:", error);
    progressCallback == null ? void 0 : progressCallback(
      processedImages,
      totalImages,
      t("images.processingError")
    );
    new import_obsidian4.Notice(t("images.processingError"));
  }
  return updatedMovieShow;
}

// Views/suggest_modal.ts
var ItemsSuggestModal = class extends import_obsidian5.SuggestModal {
  constructor(plugin, suggestion, onChoose) {
    super(plugin.app);
    this.plugin = plugin;
    this.suggestion = suggestion;
    this.onChoose = onChoose;
    this.token = "";
    this.token = plugin.settings.apiToken;
    this.kinopoiskProvider = new KinopoiskProvider({
      actorsPath: plugin.settings.actorsPath,
      directorsPath: plugin.settings.directorsPath,
      writersPath: plugin.settings.writersPath,
      producersPath: plugin.settings.producersPath
    });
  }
  // Filters suggestions by search query
  getSuggestions(query) {
    return this.suggestion.filter((item) => {
      const searchQuery = query == null ? void 0 : query.toLowerCase();
      return item.name.toLowerCase().includes(searchQuery) || item.alternativeName.toLowerCase().includes(searchQuery);
    });
  }
  // Validates image URL
  isValidImageUrl(url) {
    if (!url || url.trim() === "") return false;
    try {
      new URL(url);
      return url.startsWith("http://") || url.startsWith("https://");
    } catch (e) {
      return false;
    }
  }
  // Creates poster image element or placeholder
  createPosterElement(item, container) {
    var _a;
    const posterUrl = (_a = item.poster) == null ? void 0 : _a.url;
    if (this.isValidImageUrl(posterUrl)) {
      const imgElement = container.createEl("img", {
        cls: "kinopoisk-plugin__suggest-poster"
      });
      imgElement.src = posterUrl;
      imgElement.addEventListener("error", () => {
        const placeholder = container.createEl("div", {
          text: t("modals.posterPlaceholderEmoji"),
          cls: "kinopoisk-plugin__suggest-poster-placeholder"
        });
        placeholder.title = t("modals.posterTooltipGeoblock");
        imgElement.replaceWith(placeholder);
      });
      return imgElement;
    } else {
      const placeholder = container.createEl("div", {
        text: t("modals.posterPlaceholderEmoji"),
        cls: "kinopoisk-plugin__suggest-poster-placeholder"
      });
      const reason = !posterUrl ? t("modals.posterTooltipMissing") : posterUrl.trim() === "" ? t("modals.posterTooltipEmptyLink") : t("modals.posterTooltipInvalidLink");
      placeholder.title = reason;
      return placeholder;
    }
  }
  // Renders list item with poster and movie info
  renderSuggestion(item, el) {
    var _a, _b, _c, _d;
    const title = item.name;
    const subtitle = `\u0422\u0438\u043F: ${item.type}, \u0413\u043E\u0434: ${item.year}, KP: ${Number((_b = (_a = item.rating) == null ? void 0 : _a.kp) == null ? void 0 : _b.toFixed(0))}, IMDB: ${Number((_d = (_c = item.rating) == null ? void 0 : _c.imdb) == null ? void 0 : _d.toFixed(0))} `;
    const container = el.createEl("div", {
      cls: "kinopoisk-plugin__suggest-item"
    });
    this.createPosterElement(item, container);
    const textInfo = container.createEl("div", {
      cls: "kinopoisk-plugin__suggest-text-info"
    });
    textInfo.appendChild(el.createEl("div", { text: title }));
    textInfo.appendChild(el.createEl("small", { text: subtitle }));
  }
  // Handles item selection
  onChooseSuggestion(item) {
    this.getItemDetails(item);
  }
  // Manages loading notice display
  updateStatus(message, persistent = true) {
    this.hideLoadingNotice();
    this.loadingNotice = new import_obsidian5.Notice(message, persistent ? 0 : 3e3);
  }
  // Hides loading notice
  hideLoadingNotice() {
    if (this.loadingNotice) {
      this.loadingNotice.hide();
      this.loadingNotice = void 0;
    }
  }
  // Updates existing loading notice text
  updateLoadingNotice(message) {
    if (this.loadingNotice) {
      const noticeEl = this.loadingNotice.noticeEl;
      if (noticeEl) {
        noticeEl.textContent = message;
      }
    } else {
      this.updateStatus(message);
    }
  }
  // Creates progress text with percentage
  createProgressText(current, total, task) {
    if (total === 0) return task;
    const percentage = Math.round(current / total * 100);
    const progressBar = this.createProgressBar(current, total);
    return `${task}
${progressBar} ${current}/${total} (${percentage}%)`;
  }
  // Creates visual progress bar from characters
  createProgressBar(current, total, length = 20) {
    if (total === 0) return "";
    const filled = Math.round(current / total * length);
    const empty = length - filled;
    return "\u2588".repeat(filled) + "\u2591".repeat(empty);
  }
  // Validates input data
  validateInput(item) {
    var _a;
    if (!(item == null ? void 0 : item.id) || item.id <= 0) {
      new import_obsidian5.Notice(t("modals.errorMovieData"));
      this.onChoose(new Error(t("modals.errorMovieData")));
      return false;
    }
    if (!((_a = this.token) == null ? void 0 : _a.trim())) {
      new import_obsidian5.Notice(t("modals.needApiToken"));
      this.onChoose(new Error(t("modals.needApiToken")));
      return false;
    }
    return true;
  }
  // Fetches movie data via API
  async fetchMovieData(itemId) {
    return await this.kinopoiskProvider.getMovieById(itemId, this.token);
  }
  // Processes movie images with progress tracking
  async processMovieImages(movieShow) {
    this.updateLoadingNotice(t("modals.preparingImages"));
    let imageProcessingCompleted = false;
    const progressCallback = (current, total, currentTask) => {
      const progressText = this.createProgressText(
        current,
        total,
        currentTask
      );
      this.updateLoadingNotice(progressText);
      if (current === total) {
        imageProcessingCompleted = true;
      }
    };
    const processedMovieShow = await processImages(
      this.plugin.app,
      movieShow,
      this.plugin.settings,
      progressCallback
    );
    if (imageProcessingCompleted) {
      await new Promise((resolve) => setTimeout(resolve, 1e3));
    }
    return processedMovieShow;
  }
  // Handles successful data retrieval
  handleSuccess(movieShow, hadImageProcessing = false) {
    this.hideLoadingNotice();
    if (!hadImageProcessing) {
      new import_obsidian5.Notice(t("modals.movieInfoLoaded"));
    }
    this.onChoose(null, movieShow);
  }
  // Handles errors during data retrieval
  handleError(error) {
    this.hideLoadingNotice();
    const errorMessage = error instanceof Error ? error.message : t("modals.errorGettingDetails");
    new import_obsidian5.Notice(errorMessage);
    console.error("Error getting movie details:", error);
    this.onChoose(error);
  }
  // Fetches detailed movie information with image processing and progress tracking
  async getItemDetails(item) {
    if (!this.validateInput(item)) {
      return;
    }
    try {
      this.updateStatus(t("modals.loadingMovieInfo"));
      const movieShow = await this.fetchMovieData(item.id);
      if (!this.plugin.settings.saveImagesLocally) {
        this.handleSuccess(movieShow, false);
        return;
      }
      const processedMovieShow = await this.processMovieImages(movieShow);
      this.handleSuccess(processedMovieShow, true);
    } catch (error) {
      this.handleError(error);
    }
  }
  // Clean up notices on close
  onClose() {
    this.hideLoadingNotice();
    super.onClose();
  }
};

// Settings/settings.ts
var import_obsidian8 = require("obsidian");

// Settings/Suggesters/FolderSuggester.ts
var import_obsidian6 = require("obsidian");
var FolderSuggest = class extends import_obsidian6.AbstractInputSuggest {
  constructor(app, textInputEl, onSelectFolder) {
    super(app, textInputEl);
    this.onSelectFolder = onSelectFolder;
  }
  /**
   * Get folders matching input text
   */
  getSuggestions(inputStr) {
    if (!inputStr) {
      return [];
    }
    try {
      const abstractFiles = this.app.vault.getAllLoadedFiles();
      const folders = [];
      const lowerCaseInputStr = inputStr.toLowerCase();
      abstractFiles.forEach((folder) => {
        if (folder instanceof import_obsidian6.TFolder && folder.path.toLowerCase().includes(lowerCaseInputStr)) {
          folders.push(folder);
        }
      });
      return folders.slice(0, 20);
    } catch (error) {
      console.error(t("suggesters.folderListError"), error);
      return [];
    }
  }
  renderSuggestion(folder, el) {
    if (folder && el) {
      el.setText(folder.path);
    }
  }
  selectSuggestion(folder) {
    if (folder && folder.path) {
      this.setValue(folder.path);
      this.onSelectFolder(folder.path);
      this.close();
    }
  }
};

// Settings/Suggesters/FileSuggester.ts
var import_obsidian7 = require("obsidian");
var FileSuggest = class extends import_obsidian7.AbstractInputSuggest {
  constructor(app, textInputEl, onSelectFile) {
    super(app, textInputEl);
    this.onSelectFile = onSelectFile;
  }
  /**
   * Get files matching input text - filters only .md files
   */
  getSuggestions(inputStr) {
    if (!inputStr) {
      return [];
    }
    try {
      const abstractFiles = this.app.vault.getAllLoadedFiles();
      const files = [];
      const lowerCaseInputStr = inputStr.toLowerCase();
      abstractFiles.forEach((file) => {
        if (file instanceof import_obsidian7.TFile && file.extension === "md" && file.path.toLowerCase().includes(lowerCaseInputStr)) {
          files.push(file);
        }
      });
      return files.slice(0, 20);
    } catch (error) {
      console.error(t("suggesters.fileListError"), error);
      return [];
    }
  }
  renderSuggestion(file, el) {
    if (file && el) {
      el.setText(file.path);
    }
  }
  selectSuggestion(file) {
    if (file && file.path) {
      this.setValue(file.path);
      this.onSelectFile(file.path);
      this.close();
    }
  }
};

// Settings/settings.ts
var docUrl = "https://github.com/2PleXXX/obsidian-kinopoisk-search-plus-plugin";
var apiSite = "https://kinopoisk.dev/";
var DEFAULT_SETTINGS = {
  language: "en",
  apiToken: "",
  apiTokenValid: false,
  movieFileNameFormat: "",
  movieFolder: "",
  movieTemplateFile: "",
  seriesFileNameFormat: "",
  seriesFolder: "",
  seriesTemplateFile: "",
  // Image settings
  actorsPath: "",
  directorsPath: "",
  writersPath: "",
  producersPath: "",
  // Image defaults
  imagesFolder: "attachments/kinopoisk",
  saveImagesLocally: false,
  savePosterImage: true,
  saveCoverImage: false,
  saveLogoImage: false
};
var ObsidianKinopoiskSettingTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.validationTimeout = null;
    this.kinopoiskProvider = new KinopoiskProvider();
    setLanguage(this.plugin.settings.language);
  }
  get settings() {
    return this.plugin.settings;
  }
  onClose() {
    if (this.validationTimeout) {
      clearTimeout(this.validationTimeout);
      this.validationTimeout = null;
    }
  }
  /**
   * Update token validation visual indicator
   */
  updateTokenValidationIndicator(inputElement, isValid) {
    if (!inputElement) return;
    inputElement.removeClass(
      "kinopoisk-plugin__token-valid",
      "kinopoisk-plugin__token-invalid",
      "kinopoisk-plugin__token-checking"
    );
    if (this.plugin.settings.apiToken.trim() !== "") {
      if (isValid === null) {
        inputElement.addClass("kinopoisk-plugin__token-checking");
      } else if (isValid) {
        inputElement.addClass("kinopoisk-plugin__token-valid");
      } else {
        inputElement.addClass("kinopoisk-plugin__token-invalid");
      }
    }
  }
  /**
   * Validate token with delay
   */
  async validateTokenWithDelay(token, inputElement) {
    if (this.validationTimeout) {
      clearTimeout(this.validationTimeout);
    }
    this.updateTokenValidationIndicator(inputElement, null);
    this.validationTimeout = setTimeout(async () => {
      try {
        const isValid = await this.kinopoiskProvider.validateToken(
          token
        );
        this.plugin.settings.apiTokenValid = isValid;
        await this.plugin.saveSettings();
        this.updateTokenValidationIndicator(inputElement, isValid);
      } catch (error) {
        console.error("Token validation error:", error);
        this.plugin.settings.apiTokenValid = false;
        await this.plugin.saveSettings();
        this.updateTokenValidationIndicator(inputElement, false);
      }
    }, 1500);
  }
  /**
   * Create folder selection setting
   */
  createFolderSetting(containerEl, name, desc, placeholder, currentValue, onValueChange) {
    new import_obsidian8.Setting(containerEl).setName(name).setDesc(desc).addSearch((cb) => {
      try {
        new FolderSuggest(this.app, cb.inputEl, onValueChange);
      } catch (error) {
        console.error("Error creating FolderSuggest:", error);
      }
      cb.setPlaceholder(placeholder).setValue(currentValue).onChange(onValueChange);
    });
  }
  /**
   * Create template file selection setting
   */
  createTemplateSetting(containerEl, name, desc, placeholder, currentValue, onValueChange) {
    new import_obsidian8.Setting(containerEl).setName(name).setDesc(desc).addSearch((cb) => {
      try {
        new FileSuggest(this.app, cb.inputEl, onValueChange);
      } catch (error) {
        console.error("Error creating FileSuggest:", error);
      }
      cb.setPlaceholder(placeholder).setValue(currentValue).onChange(onValueChange);
    });
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.classList.add("obsidian-kinopoisk-plugin__settings");
    new import_obsidian8.Setting(containerEl).setName(t("settings.language")).setDesc(t("settings.languageDesc")).addDropdown((dropdown) => {
      const languages = getSupportedLanguages();
      languages.forEach((lang) => {
        dropdown.addOption(lang.code, lang.name);
      });
      dropdown.setValue(this.plugin.settings.language).onChange(async (value) => {
        this.plugin.settings.language = value;
        setLanguage(value);
        await this.plugin.saveSettings();
        this.display();
      });
    });
    const apiKeyDesc = document.createDocumentFragment();
    apiKeyDesc.createDiv({
      text: t("settings.apiTokenDesc")
    });
    apiKeyDesc.createEl("a", {
      text: t("settings.getApiToken"),
      href: apiSite
    });
    let tokenInputElement;
    new import_obsidian8.Setting(containerEl).setName(t("settings.apiToken")).setDesc(apiKeyDesc).addText((text) => {
      const textComponent = text.setPlaceholder(t("settings.enterToken")).setValue(this.plugin.settings.apiToken).onChange(async (value) => {
        this.plugin.settings.apiToken = value.trim();
        this.plugin.settings.apiTokenValid = false;
        await this.plugin.saveSettings();
        if (value.trim() !== "") {
          await this.validateTokenWithDelay(
            value.trim(),
            textComponent.inputEl
          );
        } else {
          if (this.validationTimeout) {
            clearTimeout(this.validationTimeout);
            this.validationTimeout = null;
          }
          this.updateTokenValidationIndicator(
            textComponent.inputEl,
            false
          );
        }
      });
      tokenInputElement = textComponent.inputEl;
      if (this.plugin.settings.apiToken.trim() !== "") {
        this.updateTokenValidationIndicator(
          textComponent.inputEl,
          this.plugin.settings.apiTokenValid
        );
      }
      return textComponent;
    }).addButton(
      (button) => button.setButtonText(t("settings.checkToken")).setCta().onClick(async () => {
        const token = this.plugin.settings.apiToken.trim();
        if (!token) {
          new import_obsidian8.Notice(t("settings.enterToken"));
          return;
        }
        button.setDisabled(true);
        button.setButtonText(t("settings.checking"));
        try {
          new import_obsidian8.Notice(t("settings.checking"));
          const isValid = await this.kinopoiskProvider.validateToken(
            token
          );
          this.plugin.settings.apiTokenValid = isValid;
          await this.plugin.saveSettings();
          this.updateTokenValidationIndicator(
            tokenInputElement,
            isValid
          );
          new import_obsidian8.Notice(
            isValid ? t("settings.tokenValid") : t("settings.tokenInvalid")
          );
        } catch (error) {
          console.error(
            "Manual token validation error:",
            error
          );
          this.plugin.settings.apiTokenValid = false;
          await this.plugin.saveSettings();
          this.updateTokenValidationIndicator(
            tokenInputElement,
            false
          );
          new import_obsidian8.Notice(t("settings.tokenError"));
        } finally {
          button.setDisabled(false);
          button.setButtonText(t("settings.checkToken"));
        }
      })
    );
    new import_obsidian8.Setting(containerEl).setName(t("settings.imagesHeading")).setHeading();
    new import_obsidian8.Setting(containerEl).setName(t("settings.saveImagesLocally")).setDesc(t("settings.saveImagesLocallyDesc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.saveImagesLocally).onChange(async (value) => {
        this.plugin.settings.saveImagesLocally = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.saveImagesLocally) {
      this.createFolderSetting(
        containerEl,
        t("settings.imagesFolder"),
        t("settings.imagesFolderDesc"),
        t("settings.imagesFolderPlaceholder"),
        this.plugin.settings.imagesFolder,
        async (folder) => {
          this.plugin.settings.imagesFolder = folder;
          await this.plugin.saveSettings();
        }
      );
      new import_obsidian8.Setting(containerEl).setName(t("settings.savePosterImage")).setDesc(t("settings.savePosterImageDesc")).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.savePosterImage).onChange(async (value) => {
          this.plugin.settings.savePosterImage = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian8.Setting(containerEl).setName(t("settings.saveCoverImage")).setDesc(t("settings.saveCoverImageDesc")).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.saveCoverImage).onChange(async (value) => {
          this.plugin.settings.saveCoverImage = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian8.Setting(containerEl).setName(t("settings.saveLogoImage")).setDesc(t("settings.saveLogoImageDesc")).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.saveLogoImage).onChange(async (value) => {
          this.plugin.settings.saveLogoImage = value;
          await this.plugin.saveSettings();
        })
      );
    }
    new import_obsidian8.Setting(containerEl).setName(t("settings.moviesHeading")).setHeading();
    new import_obsidian8.Setting(containerEl).setName(t("settings.movieFileName")).setDesc(t("settings.movieFileNameDesc")).addText(
      (text) => text.setPlaceholder(t("settings.movieFileNamePlaceholder")).setValue(this.plugin.settings.movieFileNameFormat).onChange(async (value) => {
        this.plugin.settings.movieFileNameFormat = value;
        await this.plugin.saveSettings();
      })
    );
    this.createFolderSetting(
      containerEl,
      t("settings.movieFileLocation"),
      t("settings.movieFileLocationDesc"),
      t("settings.movieFileLocationPlaceholder"),
      this.plugin.settings.movieFolder,
      async (folder) => {
        this.plugin.settings.movieFolder = folder;
        await this.plugin.saveSettings();
      }
    );
    const movieTemplateFileDesc = document.createDocumentFragment();
    movieTemplateFileDesc.createDiv({
      text: t("settings.movieTemplateFileDesc")
    });
    movieTemplateFileDesc.createEl("a", {
      text: t("settings.exampleTemplate"),
      href: `${docUrl}#example-template`
    });
    this.createTemplateSetting(
      containerEl,
      t("settings.movieTemplateFile"),
      movieTemplateFileDesc,
      t("settings.movieTemplateFilePlaceholder"),
      this.plugin.settings.movieTemplateFile,
      async (file) => {
        this.plugin.settings.movieTemplateFile = file;
        await this.plugin.saveSettings();
      }
    );
    new import_obsidian8.Setting(containerEl).setName(t("settings.seriesHeading")).setHeading();
    new import_obsidian8.Setting(containerEl).setName(t("settings.seriesFileName")).setDesc(t("settings.seriesFileNameDesc")).addText(
      (text) => text.setPlaceholder(t("settings.seriesFileNamePlaceholder")).setValue(this.plugin.settings.seriesFileNameFormat).onChange(async (value) => {
        this.plugin.settings.seriesFileNameFormat = value;
        await this.plugin.saveSettings();
      })
    );
    this.createFolderSetting(
      containerEl,
      t("settings.seriesFileLocation"),
      t("settings.seriesFileLocationDesc"),
      t("settings.seriesFileLocationPlaceholder"),
      this.plugin.settings.seriesFolder,
      async (folder) => {
        this.plugin.settings.seriesFolder = folder;
        await this.plugin.saveSettings();
      }
    );
    const seriesTemplateFileDesc = document.createDocumentFragment();
    seriesTemplateFileDesc.createDiv({
      text: t("settings.seriesTemplateFileDesc")
    });
    seriesTemplateFileDesc.createEl("a", {
      text: t("settings.exampleTemplate"),
      href: `${docUrl}#example-template`
    });
    this.createTemplateSetting(
      containerEl,
      t("settings.seriesTemplateFile"),
      seriesTemplateFileDesc,
      t("settings.seriesTemplateFilePlaceholder"),
      this.plugin.settings.seriesTemplateFile,
      async (file) => {
        this.plugin.settings.seriesTemplateFile = file;
        await this.plugin.saveSettings();
      }
    );
    new import_obsidian8.Setting(containerEl).setName(t("settings.peopleHeading")).setHeading();
    new import_obsidian8.Setting(containerEl).setName(t("settings.actorsFileLocation")).setDesc(t("settings.actorsFileLocationDesc")).addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl, (folder) => {
        this.plugin.settings.actorsPath = folder;
        this.plugin.saveSettings();
      });
      cb.setPlaceholder(t("settings.actorsFileLocationPlaceholder")).setValue(this.plugin.settings.actorsPath).onChange(async (newFolder) => {
        this.plugin.settings.actorsPath = newFolder;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian8.Setting(containerEl).setName(t("settings.directorsFileLocation")).setDesc(t("settings.directorsFileLocationDesc")).addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl, (folder) => {
        this.plugin.settings.directorsPath = folder;
        this.plugin.saveSettings();
      });
      cb.setPlaceholder(t("settings.directorsFileLocationPlaceholder")).setValue(this.plugin.settings.directorsPath).onChange(async (newFolder) => {
        this.plugin.settings.directorsPath = newFolder;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian8.Setting(containerEl).setName(t("settings.writersFileLocation")).setDesc(t("settings.writersFileLocationDesc")).addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl, (folder) => {
        this.plugin.settings.writersPath = folder;
        this.plugin.saveSettings();
      });
      cb.setPlaceholder(t("settings.writersFileLocationPlaceholder")).setValue(this.plugin.settings.writersPath).onChange(async (newFolder) => {
        this.plugin.settings.writersPath = newFolder;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian8.Setting(containerEl).setName(t("settings.producersFileLocation")).setDesc(t("settings.producersFileLocationDesc")).addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl, (folder) => {
        this.plugin.settings.producersPath = folder;
        this.plugin.saveSettings();
      });
      cb.setPlaceholder(t("settings.producersFileLocationPlaceholder")).setValue(this.plugin.settings.producersPath).onChange(async (newFolder) => {
        this.plugin.settings.producersPath = newFolder;
        await this.plugin.saveSettings();
      });
    });
  }
};

// Utils/cursor_jumper.ts
var import_obsidian9 = require("obsidian");
var CursorJumper = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Move cursor to the beginning of active document
   */
  async jumpToNextCursorLocation() {
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
      if (!(activeView == null ? void 0 : activeView.file)) {
        return;
      }
      const editor = activeView.editor;
      if (!editor) {
        return;
      }
      editor.focus();
      editor.setCursor(0, 0);
    } catch (error) {
      console.error("Error moving cursor:", error);
    }
  }
};

// main.ts
var ObsidianKinopoiskPlugin = class extends import_obsidian10.Plugin {
  async onload() {
    await this.loadSettings();
    initializeLanguage(this.settings.language);
    this.addRibbonIcon("film", "Search in Kinopoisk", () => {
      this.createNewNote();
    });
    this.addCommand({
      id: "open-search-kinopoisk-modal",
      name: "Search",
      callback: () => {
        this.createNewNote();
      }
    });
    this.addSettingTab(new ObsidianKinopoiskSettingTab(this.app, this));
  }
  // Shows error notification to user
  showNotice(error) {
    try {
      new import_obsidian10.Notice(error.message);
    } catch (e) {
    }
  }
  // Main workflow: search -> select -> create note with template
  async createNewNote() {
    try {
      const movieShow = await this.searchMovieShow();
      const {
        movieFileNameFormat,
        movieFolder,
        seriesFileNameFormat,
        seriesFolder
      } = this.settings;
      const renderedContents = await this.getRenderedContents(movieShow);
      const fileNameFormat = movieShow.isSeries ? seriesFileNameFormat : movieFileNameFormat;
      const folderPath = movieShow.isSeries ? seriesFolder : movieFolder;
      if (folderPath && !await this.app.vault.adapter.exists(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      const fileName = await makeFileName(
        this.app,
        movieShow,
        fileNameFormat,
        folderPath
      );
      const filePath = `${folderPath}/${fileName}`;
      const targetFile = await this.app.vault.create(
        filePath,
        renderedContents
      );
      const newLeaf = this.app.workspace.getLeaf(true);
      if (!newLeaf) {
        console.warn("No new leaf");
        return;
      }
      await newLeaf.openFile(targetFile, { state: { mode: "preview" } });
      newLeaf.setEphemeralState({ rename: "all" });
      await new CursorJumper(this.app).jumpToNextCursorLocation();
    } catch (err) {
      console.warn(err);
      this.showNotice(err);
    }
  }
  // Coordinates search process: search then select from results
  async searchMovieShow() {
    const searchedItems = await this.openSearchModal();
    return await this.openSuggestModal(searchedItems);
  }
  // Opens search modal and returns found items
  async openSearchModal() {
    return new Promise((resolve, reject) => {
      return new SearchModal(this, (error, results) => {
        return error ? reject(error) : resolve(results != null ? results : []);
      }).open();
    });
  }
  // Opens suggestion modal and returns detailed info about selected item
  async openSuggestModal(items) {
    return new Promise((resolve, reject) => {
      return new ItemsSuggestModal(this, items, (error, selectedItem) => {
        return error ? reject(error) : resolve(selectedItem);
      }).open();
    });
  }
  // Loads template content and fills it with movie/series data
  async getRenderedContents(movieShow) {
    const { movieTemplateFile, seriesTemplateFile } = this.settings;
    const templateFile = movieShow.isSeries ? seriesTemplateFile : movieTemplateFile;
    if (templateFile) {
      const templateContents = await getTemplateContents(
        this.app,
        templateFile
      );
      const replacedVariable = replaceVariableSyntax(
        movieShow,
        templateContents
      );
      return replacedVariable;
    }
    return "";
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
